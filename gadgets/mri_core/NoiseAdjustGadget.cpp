#include "NoiseAdjustGadget.h"
#include "hoArmadillo.h"
#include "hoMatrix.h"
#include "hoNDArray_elemwise.h"
#include "hoNDArray_linalg.h"
#include "hoNDArray_reductions.h"
#include "io/primitives.h"
#include "log.h"
#include <boost/iterator/counting_iterator.hpp>
#ifdef USE_OMP
#include "omp.h"
#endif // USE_OMP


#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/split.hpp>
#include <typeinfo>
using namespace std::string_literals;
namespace bf = boost::filesystem;
namespace Gadgetron {
    namespace {

        template <class T> T value_or(const ISMRMRD::Optional<T>& opt, T default_value) {
            return opt ? *opt : default_value;
        }

        std::string generateMeasurementIdOfNoiseDependency(
            const std::string& noise_id, const std::string& measurement_id) {

            // TODO: Remove this hack. This hack addresses a problem with mislabeled noise dependency IDs generated by
            // the converter. We will keep this for a transition period while preserving backwards compatibility
            if (noise_id.find('_') == std::string::npos) {
                // find the scan prefix
                std::string measurementStr = measurement_id;
                size_t ind                 = measurement_id.find_last_of('_');
                if (ind != std::string::npos) {
                    measurementStr = measurement_id.substr(0, ind) + "_"s + noise_id;
                }

                return measurementStr;
            }

            return noise_id;
        }

        float bandwidth_from_header(const ISMRMRD::IsmrmrdHeader& header) {
            return value_or(header.acquisitionSystemInformation->relativeReceiverNoiseBandwidth, 0.793f);
        }

        bf::path generateNoiseDependencyFilePath(const std::string& measurement_id,
            const bf::path& noise_dependency_folder, const std::string& noise_dependency_prefix) {
            auto full_name_stored_noise_dependency
                = noise_dependency_folder / (noise_dependency_prefix + "_"s + measurement_id);

            return full_name_stored_noise_dependency;
        }

        Gadgetron::Core::optional<NoiseCovariance> loadNoiseCovariance(
            const bf::path& noise_dependency_file) {
            using namespace Core::IO;
            if (!bf::exists(noise_dependency_file))
                return Core::none;

            std::ifstream infile;
            infile.open(noise_dependency_file.string(), std::ios::in | std::ios::binary);
            if (!infile.good())
                return Core::none;

            // Read the XML header of the noise scan

            auto xml_str = read_string_from_stream<uint32_t>(infile);

            ISMRMRD::IsmrmrdHeader header;
            ISMRMRD::deserialize(xml_str.c_str(), header);

            auto noise_dwell_time_us = read<float>(infile);

            read<size_t>(infile); //We really don't need this value, so let's skip it.
            auto cov_matrix = read<hoNDArray<std::complex<float>>>(infile);

            return NoiseCovariance{ header, noise_dwell_time_us, cov_matrix };
        }


        void normalize_covariance(NoiseGatherer& ng){
            if (ng.number_of_samples > 1) {
                ng.tmp_covariance /= std::complex<float>(ng.number_of_samples - 1);
                ng.number_of_samples = 1;
            }
        }

        void saveNoiseCovariance(
            const NoiseCovariance& ncov, const bf::path& noise_dependency_file) {

            using namespace Core::IO;

            GDEBUG_STREAM("Saving noise to " << noise_dependency_file.string());
            boost::filesystem::create_directories(noise_dependency_file.parent_path());

            std::ofstream outfile;
            outfile.open(noise_dependency_file.string(), std::ios::out | std::ios::binary);

            {
                std::stringstream sstream;
                ISMRMRD::serialize(ncov.header, sstream);
                write_string_to_stream<uint32_t>(outfile, sstream.str());
            }
            write(outfile, ncov.noise_dwell_time_us);

            size_t silly_length_we_dont_really_need = (1+ncov.noise_covariance_matrix.dimensions().size())*sizeof(size_t) + ncov.noise_covariance_matrix.get_number_of_bytes();
            write(outfile, silly_length_we_dont_really_need);
            write(outfile, ncov.noise_covariance_matrix);

            {
                using namespace boost::filesystem;
                permissions(noise_dependency_file,owner_read | owner_write | others_read | group_read);
            }

        }

        std::string to_string(const std::vector<ISMRMRD::CoilLabel>& coils) {
            std::stringstream sstream;
            for (auto i = 0u; i < coils.size(); i++)
                sstream << "Coil " << i << " - " << coils[i].coilNumber << " - " << coils[i].coilName << std::endl;
            return sstream.str();
        }

        // compare coil labels of noise and data
        // if number of channels are different, return false and order.size()==0
        // if any channels in noise cannot be found in data, return false and order.size()==0
        // if all channels in noise exist in data, but order is incorrect, return false, but  and order.size()==CHA
        // if all channels in nosie match channels in data, return true
        // order gives the matching order for src and dst coils
        // e.g. [2 1 0 3] means coil 0 of src matches coil 2 of dst etc.

        bool compare_coil_label(const std::vector<ISMRMRD::CoilLabel>& src_coils,
            const std::vector<ISMRMRD::CoilLabel>& dst_coils, std::vector<size_t>& order_in_src) {
            auto coil_name_comparer
                = [](const auto& coil1, const auto& coil2) { return coil1.coilName == coil2.coilName; };
            bool labels_match = std::equal(
                src_coils.begin(), src_coils.end(), dst_coils.begin(), dst_coils.end(), coil_name_comparer);

            if (labels_match)
                return labels_match;

            if (!is_permutation(
                    src_coils.begin(), src_coils.end(), dst_coils.begin(), dst_coils.end(), coil_name_comparer))
                return false;

            order_in_src = std::vector<size_t>(dst_coils.size(), 0);
            std::iota(order_in_src.begin(), order_in_src.end(), 0);

            for (size_t d = 0u; d < order_in_src.size(); d++) {
                if (coil_name_comparer(dst_coils[d], src_coils[d]))
                    continue;
                auto coil_it    = std::find_if(src_coils.begin(), src_coils.end(),
                    [&](const auto& coil) { return coil_name_comparer(coil, dst_coils[d]); });
                order_in_src[d] = std::distance(src_coils.begin(), coil_it);
            }

            return labels_match;
        }

        hoNDArray<std::complex<float>> mask_channels(
            hoNDArray<std::complex<float>> noise_prewhitener_matrix, const std::vector<size_t>& scale_only_channels) {
            // Mask out scale  only channels
            size_t c                  = noise_prewhitener_matrix.get_size(0);
            std::complex<float>* dptr = noise_prewhitener_matrix.data();
            for (auto ch : scale_only_channels) {
                for (size_t i = 0; i < c; i++) {
                    for (size_t j = 0; j < c; j++) {
                        if ((i == ch || j == ch) && (i != j)) { // zero if scale only and not on diagonal
                            dptr[i * c + j] = std::complex<float>(0.0, 0.0);
                        }
                    }
                }
            }
            return std::move(noise_prewhitener_matrix);
        }

        hoNDArray<std::complex<float>> computeNoisePrewhitener(
            const hoNDArray<std::complex<float>>& noise_covariance_matrix) {

            auto noise_prewhitener_matrix = noise_covariance_matrix;
            size_t c                      = noise_prewhitener_matrix.get_size(0);
            float v                       = Gadgetron::asum(noise_covariance_matrix);
            if (v <= 0) {
                GDEBUG("Accumulated noise prewhitener is empty\n");
                for (size_t cha = 0; cha < c; cha++) {
                    noise_prewhitener_matrix(cha, cha) = 1;
                }
            } else {
                // Cholesky and invert lower triangular
                arma::cx_fmat noise_covf = as_arma_matrix(noise_prewhitener_matrix);
                noise_covf               = arma::inv(arma::trimatu(arma::chol(noise_covf)));
            }

            return noise_prewhitener_matrix;
        }

        std::vector<size_t> find_scale_only_channels(
            const std::string& scale_only_channels_by_name, const std::vector<ISMRMRD::CoilLabel>& coillabels) {
            if (scale_only_channels_by_name.empty())
                return {};
            // Let's figure out if some channels are "scale_only"
            const std::string& uncomb_str = scale_only_channels_by_name;
            GDEBUG("SCALE ONLY: %s\n", uncomb_str.c_str());
            std::vector<std::string> uncomb;
            boost::split(uncomb, uncomb_str, boost::is_any_of(","));
            std::vector<size_t> scale_only_channels;

            for (unsigned int i = 0; i < uncomb.size(); i++) {
                std::string ch = boost::algorithm::trim_copy(uncomb[i]);
                if (std::find_if(
                        coillabels.begin(), coillabels.end(), [&](const auto& coil) { return ch == coil.coilName; })
                    != coillabels.end())
                    scale_only_channels.push_back(i);
            }
            return scale_only_channels;
        }

        hoNDArray<std::complex<float>> reorder_noise_channels(
            hoNDArray<std::complex<float>> noise_covariance, const std::vector<size_t>& coil_order) {
            using namespace Indexing;
            // check whether to switch channel order
            auto CHA = noise_covariance.get_size(0);
            if ((coil_order.size() != CHA)
                || std::equal(coil_order.begin(), coil_order.end(), boost::counting_iterator<size_t>(0)))
                return std::move(noise_covariance);

            GDEBUG_STREAM("Require to reorder the noise covariance matrix to match the data ... ");
            hoNDArray<std::complex<float>> noise_covariance_reordered = noise_covariance;

            // switch row
            for (size_t n = 0; n < CHA; n++) {
                //hoNDArrayView<std::complex<float>,1,false> f = noise_covariance_reordered(n,slice);
                noise_covariance_reordered(n, slice) = noise_covariance(coil_order[n], slice);
            }

            // switch column
            for (size_t m = 0; m < CHA; m++) {
                noise_covariance(slice, m) = noise_covariance_reordered(slice, coil_order[m]);
            }

            return std::move(noise_covariance);
        }

        float calculate_scale_factor(
            float acquisition_dwell_time_us, float noise_dwell_time_us, float receiver_noise_bandwidth) {
            float noise_bw_scale_factor;
            if ((noise_dwell_time_us == 0.0f) || (acquisition_dwell_time_us == 0.0f)) {
                noise_bw_scale_factor = 1.0f;
            } else {
                noise_bw_scale_factor
                    = std::sqrt(2.0f * acquisition_dwell_time_us / noise_dwell_time_us * receiver_noise_bandwidth);
            }
            return noise_bw_scale_factor;
        }
    }

    NoiseAdjustGadget::NoiseAdjustGadget(const Core::Context& context, const Core::GadgetProperties& props)
        : Core::ChannelGadget<Core::Acquisition>(context, props)
        , current_ismrmrd_header(context.header)
        , receiver_noise_bandwidth{ bandwidth_from_header(context.header) }
        , measurement_id{ value_or(context.header.measurementInformation->measurementID, ""s) } {

        if (!perform_noise_adjust)
            return;

        GDEBUG("Folder to store noise dependencies is %s\n", noise_dependency_folder.c_str());
        GDEBUG("NoiseAdjustGadget::perform_noise_adjust_ is %d\n", perform_noise_adjust);
        GDEBUG("NoiseAdjustGadget::pass_nonconformant_data_ is %d\n", pass_nonconformant_data);
        GDEBUG("receiver_noise_bandwidth_ is %f\n", receiver_noise_bandwidth);

#ifdef USE_OMP
        omp_set_num_threads(1);
#endif // USE_OMP

        // find the measurementID of this scan

        noisehandler = load_or_gather();
    }

    NoiseAdjustGadget::NoiseHandler NoiseAdjustGadget::load_or_gather() const {
        GDEBUG("Measurement ID is %s\n", measurement_id.c_str());
        if (!current_ismrmrd_header.measurementInformation) {
            GWARN("ISMRMRD Header is missing measurmentinformation. Skipping noise adjust");
            return NoiseGatherer{};
        }
        const auto& measurementDependency = current_ismrmrd_header.measurementInformation->measurementDependency;
        auto val = std::find_if(measurementDependency.begin(), measurementDependency.end(), [](const auto& dependency) {
            return boost::algorithm::to_lower_copy(dependency.dependencyType) == "noise";
        });

        // find the noise depencies if any
        if (val == measurementDependency.end())
            return NoiseGatherer{};

        auto noise_dependency = *val;
        GDEBUG("Measurement ID of noise dependency is %s\n", noise_dependency.measurementID.c_str());

        auto noise_dependency_file = generateNoiseDependencyFilePath(
            generateMeasurementIdOfNoiseDependency(noise_dependency.measurementID, measurement_id),
            noise_dependency_folder, noise_dependency_prefix);
        GDEBUG("Stored noise dependency is %s\n", noise_dependency_file.c_str());

        auto noise_covariance = loadNoiseCovariance(noise_dependency_file);
        // try to load the precomputed noise prewhitener
        if (!noise_covariance) {
            GDEBUG("Stored noise dependency is NOT found : %s\n", noise_dependency_file.c_str());
            return NoiseGatherer{};
        } else {
            GDEBUG("Stored noise dependency is found : %s\n", noise_dependency_file.c_str());
            GDEBUG("Stored noise dwell time in us is %f\n", noise_covariance->noise_dwell_time_us);
            size_t CHA = noise_covariance->noise_covariance_matrix.get_size(0);
            GDEBUG("Stored noise channel number is %d\n", CHA);

            if (noise_covariance->header.acquisitionSystemInformation) {
                GDEBUG_STREAM("Noise coil info: ");
                GDEBUG_STREAM(to_string(noise_covariance->header.acquisitionSystemInformation->coilLabel));

                GDEBUG_STREAM("Data coil info: ");
                GDEBUG_STREAM(to_string(current_ismrmrd_header.acquisitionSystemInformation->coilLabel));

                std::vector<size_t> coil_order_of_data_in_noise;
                bool labels_match = compare_coil_label(noise_covariance->header.acquisitionSystemInformation->coilLabel,
                    current_ismrmrd_header.acquisitionSystemInformation->coilLabel, coil_order_of_data_in_noise);

                if (!labels_match) {
                    // if number of channels in noise is different than data
                    // or
                    // if any channels in noise do not exist in data
                    if (CHA != current_ismrmrd_header.acquisitionSystemInformation->coilLabel.size()) {
                        GDEBUG("Noise and measurement have different number of coils\n");
                    } else {
                        if (coil_order_of_data_in_noise.size() == CHA) {
                            GWARN_STREAM("Noise and meansurement have different coils, but will be reordered ... ");
                            noise_covariance->noise_covariance_matrix = reorder_noise_channels(
                                noise_covariance->noise_covariance_matrix, coil_order_of_data_in_noise);

                        } else {
                            GWARN_STREAM("Noise and meansurement have different coils and cannot be reordered ... ");
                        }
                    }
                }
                return LoadedNoise{noise_covariance->noise_covariance_matrix,noise_covariance->noise_dwell_time_us};

            } else if (current_ismrmrd_header.acquisitionSystemInformation) {
                GERROR("Noise ismrmrd header does not have acquisition system information but current header "
                       "does\n");
            }

            //                    number_of_noise_samples_ = 1; // When we load the matrix, it is already
            //                    scaled.
        }
        return NoiseGatherer{};
    }

    static bool is_noise(const Core::Acquisition& acq) {
        return std::get<ISMRMRD::AcquisitionHeader>(acq).isFlagSet(ISMRMRD::ISMRMRD_ACQ_IS_NOISE_MEASUREMENT);
    }

    template <class NOISEHANDLER>
    void NoiseAdjustGadget::add_noise(NOISEHANDLER& nh, const Gadgetron::Core::Acquisition&) const {
    }

    template <> void NoiseAdjustGadget::add_noise(NoiseGatherer& ng, const Gadgetron::Core::Acquisition& acq) const {
        auto& data    = std::get<hoNDArray<std::complex<float>>>(acq);
        auto& head    = std::get<ISMRMRD::AcquisitionHeader>(acq);
        if (ng.tmp_covariance.empty()) {
            auto channels = head.active_channels;
            ng.tmp_covariance = hoNDArray<std::complex<float>>(channels, channels);
            std::fill(ng.tmp_covariance.begin(), ng.tmp_covariance.end(), std::complex<float>(0));
        }

        if (ng.noise_dwell_time_us == 0)
            ng.noise_dwell_time_us = head.sample_time_us;

        auto dataM = as_arma_matrix(data);
        auto covariance = as_arma_matrix(ng.tmp_covariance);
        covariance += dataM.t()*dataM;


        ng.number_of_samples += head.number_of_samples;
    }

    template <> void NoiseAdjustGadget::add_noise(NoiseHandler& nh, const Gadgetron::Core::Acquisition& acq) const {
        Core::visit([&](auto& var) { this->add_noise(var, acq); }, nh);
    }
    template <class NOISEHANDLER> void NoiseAdjustGadget::save_noisedata(NOISEHANDLER& nh) const {}

    template <> void NoiseAdjustGadget::save_noisedata(NoiseGatherer& ng) const {
        if (ng.tmp_covariance.empty())
            return;

        normalize_covariance(ng);

        saveNoiseCovariance(
            NoiseCovariance{ this->current_ismrmrd_header, ng.noise_dwell_time_us, ng.tmp_covariance },
            generateNoiseDependencyFilePath(measurement_id, noise_dependency_folder, noise_dependency_prefix));
    }

    template <> void NoiseAdjustGadget::save_noisedata(NoiseHandler& nh) const {
        Core::visit([&](auto& var) { this->save_noisedata(var); }, nh);
    }


    template <class NH>
    NoiseAdjustGadget::NoiseHandler NoiseAdjustGadget::handle_acquisition(NH nh, Core::Acquisition& acq) const {
        GDEBUG_STREAM("Noone with type " << typeid(nh).name() <<  " handles dem acquisitions");
        return std::move(nh);
    };

    template <>
    NoiseAdjustGadget::NoiseHandler NoiseAdjustGadget::handle_acquisition(
        Prewhitener pw, Core::Acquisition& acq) const {

        auto& data = std::get<hoNDArray<std::complex<float>>>(acq);
        if (data.get_size(1) == pw.prewhitening_matrix.get_size(0)) {
            auto dataM = as_arma_matrix(data);
            auto pwm = as_arma_matrix(pw.prewhitening_matrix);
            dataM *= pwm;
        } else if (!this->pass_nonconformant_data) {
            throw std::runtime_error("Input data has different number of channels from noise data");
        }
        return std::move(pw);
    }

    template <>
    NoiseAdjustGadget::NoiseHandler NoiseAdjustGadget::handle_acquisition(
        NoiseGatherer ng, Core::Acquisition& acq) const {
        auto& head = std::get<ISMRMRD::AcquisitionHeader>(acq);
        if (ng.number_of_samples == 0)
            return std::move(ng);


        normalize_covariance(ng);
        this->save_noisedata(ng);

        auto masked_covariance = mask_channels(ng.tmp_covariance, scale_only_channels);

        auto prewhitening_matrix = computeNoisePrewhitener(masked_covariance);
        prewhitening_matrix
            *= calculate_scale_factor(head.sample_time_us, ng.noise_dwell_time_us, receiver_noise_bandwidth);
        return handle_acquisition(Prewhitener{ prewhitening_matrix }, acq);
    }

    template <>
    NoiseAdjustGadget::NoiseHandler NoiseAdjustGadget::handle_acquisition(
        LoadedNoise ln, Core::Acquisition& acq) const {
        auto& head               = std::get<ISMRMRD::AcquisitionHeader>(acq);
        auto masked_covariance   = mask_channels(std::move(ln.covariance), scale_only_channels);
        auto prewhitening_matrix = computeNoisePrewhitener(masked_covariance);
        prewhitening_matrix
            *= calculate_scale_factor(head.sample_time_us, ln.noise_dwell_time_us, receiver_noise_bandwidth);
        return handle_acquisition(Prewhitener{ prewhitening_matrix }, acq);
    }

    template <>
    NoiseAdjustGadget::NoiseHandler NoiseAdjustGadget::handle_acquisition(
        NoiseHandler nh, Core::Acquisition& acq) const {
        return Core::visit([&](auto var) { return this->handle_acquisition<decltype(var)>(std::move(var), acq); }, std::move(nh));
    }



    void NoiseAdjustGadget::process(Core::InputChannel<Core::Acquisition>& input, Core::OutputChannel& output) {

        scale_only_channels = current_ismrmrd_header.acquisitionSystemInformation
                                  ? find_scale_only_channels(scale_only_channels_by_name,
                                      current_ismrmrd_header.acquisitionSystemInformation->coilLabel)
                                  : std::vector<size_t>{};

        auto filepath
            = generateNoiseDependencyFilePath(measurement_id, noise_dependency_folder, noise_dependency_prefix);

        for (auto acq : input) {
            if (is_noise(acq)) {
                add_noise(noisehandler, acq);
                continue;
            }
            noisehandler = handle_acquisition(std::move(noisehandler), acq);
            output.push(std::move(acq));
        }

        this->save_noisedata(noisehandler);
    }

    GADGETRON_GADGET_EXPORT(NoiseAdjustGadget)

} // namespace Gadgetron
