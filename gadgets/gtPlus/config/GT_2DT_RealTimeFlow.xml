<?xml version="1.0" encoding="utf-8"?>
<gadgetronStreamConfiguration xsi:schemaLocation="http://gadgetron.sf.net/gadgetron gadgetron.xsd"
        xmlns="http://gadgetron.sf.net/gadgetron"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <!--
       _____              _____     _____   ______   _______   _____     ____    _   _ 
      / ____|     /\     |  __ \   / ____| |  ____| |__   __| |  __ \   / __ \  | \ | |
     | |  __     /  \    | |  | | | |  __  | |__       | |    | |__) | | |  | | |  \| |
     | | |_ |   / /\ \   | |  | | | | |_ | |  __|      | |    |  _  /  | |  | | | . ` |
     | |__| |  / ____ \  | |__| | | |__| | | |____     | |    | | \ \  | |__| | | |\  |
      \_____| /_/    \_\ |_____/   \_____| |______|    |_|    |_|  \_\  \____/  |_| \_|
                                                                                       
    -->

    <!-- 
        GT Plus configuratin file for 2DT cartesian reconstruction on real-time flow imaging
        The GtPlus supports the on-the-fly reconstruction, therefore the reconstruction starts 
        whenever sufficient data is received. The reconstructed images are sent out once the 
        computation is finished.

        Author: Hui Xue
        Magnetic Resonance Technology Program
        National Heart, Lung and Blood Institute
        National Institutes of Health
        10 Center Drive, Bethesda
        MD 20814
        USA
        Email: hui.xue@nih.gov
    -->

    <!-- reader -->
    <reader>
        <slot>1008</slot>
        <dll>gadgetron_mricore</dll>
        <classname>GadgetIsmrmrdAcquisitionMessageReader</classname>
    </reader>

    <!-- writer -->
    <writer>
        <slot>1004</slot>
        <dll>gadgetron_mricore</dll>
        <classname>MRIImageWriterCPLX</classname>
    </writer>
    <writer>
        <slot>1005</slot>
        <dll>gadgetron_mricore</dll>
        <classname>MRIImageWriterFLOAT</classname>
    </writer>
    <writer>
        <slot>1006</slot>
        <dll>gadgetron_mricore</dll>
        <classname>MRIImageWriterUSHORT</classname>
    </writer>

    <writer>
        <slot>1015</slot>
        <dll>gadgetron_mricore</dll>
        <classname>MRIImageAttribWriterCPLX</classname>
    </writer>
    <writer>
        <slot>1016</slot>
        <dll>gadgetron_mricore</dll>
        <classname>MRIImageAttribWriterFLOAT</classname>
    </writer>
    <writer>
        <slot>1017</slot>
        <dll>gadgetron_mricore</dll>
        <classname>MRIImageAttribWriterUSHORT</classname>
    </writer>

    <!-- RO asymmetric echo handling -->
    <gadget>
        <name>AsymmetricEcho</name>
        <dll>gadgetron_mricore</dll>
        <classname>AsymmetricEchoAdjustROGadget</classname>
    </gadget>

    <!-- Noise prewhitening -->
    <gadget>
        <name>NoiseAdjust</name>
        <dll>gadgetron_mricore</dll>
        <classname>NoiseAdjustGadget</classname>
    </gadget>

    <!-- RO oversampling removal -->
    <gadget>
        <name>RemoveROOversampling</name>
        <dll>gadgetron_mricore</dll>
        <classname>RemoveROOversamplingGadget</classname>
    </gadget>

    <gadget>
        <name>Acc</name>
        <dll>gadgetronPlus</dll>
        <classname>GtPlusAccumulatorWorkOrderTriggerGadget</classname>

        <!-- debug and info mode -->
        <property>
            <name>verboseMode</name>
            <value>false</value>
        </property>

        <!-- No acceleration mode -->
        <property>
            <name>noacceleration_triggerDim1</name>
            <value>DIM_None</value>
        </property>

        <property>
            <name>noacceleration_triggerDim2</name>
            <value>DIM_Slice</value>
        </property>

        <property>
            <name>noacceleration_numOfKSpace_triggerDim1</name>
            <value>1</value>
        </property>

        <!-- Interleaved mode -->
        <property>
            <name>interleaved_triggerDim1</name>
            <value>DIM_None</value>
        </property>

        <property>
            <name>interleaved_triggerDim2</name>
            <value>DIM_Slice</value>
        </property>

        <property>
            <name>interleaved_numOfKSpace_triggerDim1</name>
            <value>4</value>
        </property>

        <!-- Embedded mode -->
        <property>
            <name>embedded_triggerDim1</name>
            <value>DIM_None</value>
        </property>

        <property>
            <name>embedded_triggerDim2</name>
            <value>DIM_Slice</value>
        </property>

        <property>
            <name>embedded_numOfKSpace_triggerDim1</name>
            <value>1</value>
        </property>

        <!-- Separate mode -->
        <property>
            <name>separate_triggerDim1</name>
            <value>DIM_None</value>
        </property>

        <property>
            <name>separate_triggerDim2</name>
            <value>DIM_Slice</value>
        </property>

        <property>
            <name>separate_numOfKSpace_triggerDim1</name>
            <value>1</value>
        </property>

        <!-- if 'other' kspace data presents, enforce its dimension matches the image data-->
        <property>
            <name>other_kspace_matching_Dim</name>
            <value>DIM_Repetition</value>
        </property>

    </gadget>

    <!--
    Recon computation for 2DT cases

    kspace_: [RO E1 CHA N S], for 2D recon, N can be 1
    ref_: [RO E1 CHA M S], M can equal to N or 1 or others
    fullkspace_: [RO E1 CHA N S]
    complexIm_: [RO E1 N S], after coil combination
    coilMap_: [RO E1 CHA 1 or N S]
    gfactor_: [RO E1 CHA 1 or N S]

    the 4th and 5th dimensions (N and S) needs to be specified. For example,
    for real-time cine, N = DIM_Phase and S=DIM_Slice

    default behavior
    a) the coil compression coefficients are computed once across all S
    b) the kernel or coil sensitivity are estimated for every S

    embedded mode
    a) perform recon and estimate kernel/coil sensitivity for every 2D kspace [RO E1 CHA]
    b) coil combination uses different coil maps for every S
    c) if the kspace recon is performed, the coil combination map is reestimated on the fullkspace for every 2D images
    d) the ref lines are filled back to fullkspace_

    separate mode
    a) perform recon and estimate kernel/coil sensitivity for every 2D kspace [RO E1 CHA] if M==N
    b) if M==1, the kernel is only estimated once for every S
    c) coil combination uses different coil maps for every S
    d) if the kspace recon is performed, the coil combination map is reestimated on the fullkspace for every 2D images

    interleave
    a) the average-all ref is used
    b) kernel/coil sensitivity is estimated once for every S
    -->

    <gadget>
        <name>Recon</name>
        <dll>gadgetronPlus</dll>
        <classname>GtPlusRecon2DTGadget</classname>

        <!-- kspace data -->
        <property>
            <name>dim_4th</name>
            <value>DIM_Phase</value>
        </property>
        <property>
            <name>dim_5th</name>
            <value>DIM_Set</value>
        </property>

        <!-- work flow -->
        <property>
            <name>workOrder_ShareDim</name>
            <value>DIM_NONE</value>
        </property>

        <!-- No acceleration mode -->
        <property>
            <name>no_acceleration_averageall_ref</name>
            <value>true</value>
        </property>
        <property>
            <name>no_acceleration_ref_numOfModes</name>
            <value>0</value>
        </property>
        <property>
            <name>no_acceleration_same_combinationcoeff_allS</name>
            <value>true</value>
        </property>
        <property>
            <name>no_acceleration_whichS_combinationcoeff</name>
            <value>0</value>
        </property>

        <!-- Interleaved mode -->
        <property>
            <name>interleaved_same_combinationcoeff_allS</name>
            <value>true</value>
        </property>
        <property>
            <name>interleaved_whichS_combinationcoeff</name>
            <value>0</value>
        </property>
        <property>
            <name>interleaved_ref_numOfModes</name>
            <value>0</value>
        </property>

        <!-- Embedded mode -->
        <property>
            <name>embedded_averageall_ref</name>
            <value>true</value>
        </property>
        <property>
            <name>embedded_ref_numOfModes</name>
            <value>0</value>
        </property>
        <property>
            <name>embedded_fullres_coilmap</name>
            <value>false</value>
        </property>
        <property>
            <name>embedded_fullres_coilmap_useHighestSignal</name>
            <value>false</value>
        </property>
        <property>
            <name>embedded_same_combinationcoeff_allS</name>
            <value>true</value>
        </property>
        <property>
            <name>embedded_whichS_combinationcoeff</name>
            <value>0</value>
        </property>
        <property>
            <name>embedded_ref_fillback</name>
            <value>true</value>
        </property>

        <!-- Separate mode -->
        <property>
            <name>separate_averageall_ref</name>
            <value>true</value>
        </property>
        <property>
            <name>separate_ref_numOfModes</name>
            <value>0</value>
        </property>
        <property>
            <name>separate_fullres_coilmap</name>
            <value>false</value>
        </property>
        <property>
            <name>separate_same_combinationcoeff_allS</name>
            <value>true</value>
        </property>
        <property>
            <name>separate_whichS_combinationcoeff</name>
            <value>0</value>
        </property>

        <!-- coil compression -->
        <property>
            <name>same_coil_compression_coeff_allS</name>
            <value>true</value>
        </property>

        <property>
            <name>downstream_coil_compression</name>
            <value>true</value>
        </property>

        <property>
            <name>coil_compression_thres</name>
            <value>0.001</value>
        </property>

        <property>
            <name>coil_compression_num_modesKept</name>
            <value>-1</value>
        </property>

        <!-- parameters for coil map estimation 
            enum ISMRMRDCOILMAPALGO
            {
                ISMRMRD_SOUHEIL,
                ISMRMRD_SOUHEIL_ITER
            };
        -->
        <property>
            <name>coil_map_algorithm</name>
            <value>ISMRMRD_SOUHEIL</value>
        </property>
        <property>
            <name>csm_kSize</name>
            <value>7</value>
        </property>

        <property>
            <name>csm_powermethod_num</name>
            <value>3</value>
        </property>

        <property>
            <name>csm_true_3D</name>
            <value>false</value>
        </property>

        <property>
            <name>csm_iter_num</name>
            <value>5</value>
        </property>

        <property>
            <name>csm_iter_thres</name>
            <value>0.001</value>
        </property>

        <property>
            <name>csm_use_gpu</name>
            <value>false</value>
        </property>

        <!-- algorithm -->
        <property>
            <name>recon_algorithm</name>
            <value>ISMRMRD_GRAPPA</value>
        </property>

        <property>
            <name>recon_kspace_needed</name>
            <value>false</value>
        </property>

        <property>
            <name>gfactor_needed</name>
            <value>false</value>
        </property>

        <!-- parameters for ISMRMRD_GRAPPA -->
        <property>
            <name>grappa_kSize_RO</name>
            <value>5</value>
        </property>
        <property>
            <name>grappa_kSize_E1</name>
            <value>4</value>
        </property>
        <property>
            <name>grappa_kSize_E2</name>
            <value>4</value>
        </property>
        <property>
            <name>grappa_reg_lamda</name>
            <value>0.0005</value>
        </property>
        <property>
            <name>grappa_calib_over_determine_ratio</name>
            <value>0</value>
        </property>
        <property>
            <name>grappa_use_gpu</name>
            <value>false</value>
        </property>

        <!-- parameters for ISMRMRD_SPIRIT -->
        <property>
            <name>spirit_kSize_RO</name>
            <value>7</value>
        </property>
        <property>
            <name>spirit_kSize_E1</name>
            <value>7</value>
        </property>
        <property>
            <name>spirit_kSize_E2</name>
            <value>5</value>
        </property>
        <property>
            <name>spirit_reg_lamda</name>
            <value>0.005</value>
        </property>
        <property>
            <name>spirit_use_gpu</name>
            <value>false</value>
        </property>
        <property>
            <name>spirit_iter_max</name>
            <value>70</value>
        </property>
        <property>
            <name>spirit_iter_thres</name>
            <value>1e-5</value>
        </property>

        <!-- parameters for scaling and image sending -->
        <property>
            <name>min_intensity_value</name>
            <value>64</value>
        </property>

        <property>
            <name>max_intensity_value</name>
            <value>4095</value>
        </property>

        <property>
            <name>scalingFactor</name>
            <value>-1.0</value>
        </property>

        <property>
            <name>use_constant_scalingFactor</name>
            <value>false</value>
        </property>

        <!-- parameters for kspace filter, image data -->
        <property>
            <name>filterRO</name>
            <value>ISMRMRD_FILTER_GAUSSIAN</value>
        </property>
        <property>
            <name>filterRO_sigma</name>
            <value>1.0</value>
        </property>
        <property>
            <name>filterRO_width</name>
            <value>0.15</value>
        </property>

        <property>
            <name>filterE1</name>
            <value>ISMRMRD_FILTER_GAUSSIAN</value>
        </property>
        <property>
            <name>filterE1_sigma</name>
            <value>1.0</value>
        </property>
        <property>
            <name>filterE1_width</name>
            <value>0.15</value>
        </property>

        <property>
            <name>filterE2</name>
            <value>ISMRMRD_FILTER_GAUSSIAN</value>
        </property>
        <property>
            <name>filterE2_sigma</name>
            <value>1.0</value>
        </property>
        <property>
            <name>filterE2_width</name>
            <value>0.15</value>
        </property>

        <!-- parameters for kspace filter, ref data -->
        <property>
            <name>filterRefRO</name>
            <value>ISMRMRD_FILTER_HANNING</value>
        </property>
        <property>
            <name>filterRefRO_sigma</name>
            <value>1.5</value>
        </property>
        <property>
            <name>filterRefRO_width</name>
            <value>0.15</value>
        </property>

        <property>
            <name>filterRefE1</name>
            <value>ISMRMRD_FILTER_HANNING</value>
        </property>
        <property>
            <name>filterRefE1_sigma</name>
            <value>1.5</value>
        </property>
        <property>
            <name>filterRefE1_width</name>
            <value>0.15</value>
        </property>

        <property>
            <name>filterRefE2</name>
            <value>ISMRMRD_FILTER_HANNING</value>
        </property>
        <property>
            <name>filterRefE2_sigma</name>
            <value>1.5</value>
        </property>
        <property>
            <name>filterRefE2_width</name>
            <value>0.15</value>
        </property>

        <!-- parameters for kspace filter, partial fourier/asymmetric echo filter -->
        <property>
            <name>filterPartialFourierRO</name>
            <value>ISMRMRD_FILTER_TAPERED_HANNING</value>
        </property>
        <property>
            <name>filterPartialFourierRO_sigma</name>
            <value>1.5</value>
        </property>
        <property>
            <name>filterPartialFourierRO_width</name>
            <value>0.15</value>
        </property>
        <property>
            <name>filterPartialFourierRO_densityComp</name>
            <value>true</value>
        </property>

        <property>
            <name>filterPartialFourierE1</name>
            <value>ISMRMRD_FILTER_TAPERED_HANNING</value>
        </property>
        <property>
            <name>filterPartialFourierE1_sigma</name>
            <value>1.5</value>
        </property>
        <property>
            <name>filterPartialFourierE1_width</name>
            <value>0.15</value>
        </property>
        <property>
            <name>filterPartialFourierE1_densityComp</name>
            <value>true</value>
        </property>

        <property>
            <name>filterPartialFourierE2</name>
            <value>ISMRMRD_FILTER_TAPERED_HANNING</value>
        </property>
        <property>
            <name>filterPartialFourierE2_sigma</name>
            <value>1.5</value>
        </property>
        <property>
            <name>filterPartialFourierE2_width</name>
            <value>0.15</value>
        </property>
        <property>
            <name>filterPartialFourierE2_densityComp</name>
            <value>true</value>
        </property>

        <!-- parameters for partial fourier handling algorithm, ISMRMRD_PF_HOMODYNE, ISMRMRD_PF_POCS, ISMRMRD_PF_FENGHUANG, ISMRMRD_PF_ZEROFILLING_FILTER, ISMRMRD_PF_ZEROFILLING -->
        <property>
            <name>partialFourier_algo</name>
            <value>ISMRMRD_PF_FENGHUANG</value>
        </property>

        <!-- parameters for partial fourier homodyne algorithm -->
        <property>
            <name>partialFourier_homodyne_iters</name>
            <value>6</value>
        </property>
        <property>
            <name>partialFourier_homodyne_thres</name>
            <value>0.01</value>
        </property>
        <property>
            <name>partialFourier_homodyne_densityComp</name>
            <value>false</value>
        </property>

        <!-- parameters for partial fourier POCS algorithm -->
        <property>
            <name>partialFourier_POCS_iters</name>
            <value>6</value>
        </property>
        <property>
            <name>partialFourier_POCS_thres</name>
            <value>0.01</value>
        </property>
        <property>
            <name>partialFourier_POCS_transitBand</name>
            <value>24</value>
        </property>

        <!-- parameters for partial fourier FengHuang algorithm -->
        <property>
            <name>partialFourier_FengHuang_kSize_RO</name>
            <value>5</value>
        </property>
        <property>
            <name>partialFourier_FengHuang_kSize_E1</name>
            <value>5</value>
        </property>
        <property>
            <name>partialFourier_FengHuang_kSize_E2</name>
            <value>5</value>
        </property>
        <property>
            <name>partialFourier_FengHuang_thresReg</name>
            <value>0.01</value>
        </property>
        <property>
            <name>partialFourier_FengHuang_sameKernel_allN</name>
            <value>false</value>
        </property>
        <property>
            <name>partialFourier_FengHuang_transitBand</name>
            <value>24</value>
        </property>

        <!-- parameters for debug and timing -->
        <property>
            <name>debugFolder</name>
            <value></value>
        </property>

        <property>
            <name>debugFolder2</name>
            <value></value>
        </property>

        <property>
            <name>performTiming</name>
            <value>true</value>
        </property>

        <property>
            <name>verboseMode</name>
            <value>false</value>
        </property>

        <!-- parameters for system acquisition -->
        <property>
            <name>timeStampResolution</name>
            <value>0.0025</value>
        </property>

    </gadget>

    <!-- flow processing -->
    <gadget>
        <name>PhaseSubtraction</name>
        <dll>gadgetron_mricore</dll>
        <classname>FlowPhaseSubtractionGadget</classname>
    </gadget>

    <gadget>
        <name>MaxwellCorrection</name>
        <dll>gadgetron_mricore</dll>
        <classname>MaxwellCorrectionGadget</classname>
    </gadget>

    <gadget>
        <name>Extract</name>
        <dll>gadgetron_mricore</dll>
        <classname>ExtractGadget</classname>
        <property>
            <name>extract_mask</name>
            <value>9</value>
        </property>
        <property>
            <name>scaling_factor_angle</name>
            <value>1.0</value>
        </property>
    </gadget>

    <!-- after recon processing -->
    <!--
    <gadget>
        <name>ComplexToFloatAttrib</name>
        <dll>gadgetron_mricore</dll>
        <classname>ComplexToFloatAttribGadget</classname>
    </gadget>
    -->

    <gadget>
        <name>FloatToShortAttrib</name>
        <dll>gadgetron_mricore</dll>
        <classname>FloatToUShortAttribGadget</classname>

        <property>
            <name>intensity_offset</name>
            <value>2048</value>
        </property>
    </gadget>

    <!--
    <gadget>
      <name>ImageFinishAttribCPLX</name>
      <dll>gadgetron_mricore</dll>
      <classname>ImageFinishAttribGadgetCPLX</classname>
    </gadget>
    -->

    <!--
    <gadget>
      <name>ImageFinishAttribFLOAT</name>
      <dll>gadgetron_mricore</dll>
      <classname>ImageFinishAttribGadgetFLOAT</classname>
    </gadget>
    -->

    <gadget>
        <name>ImageFinishAttribUSHORT</name>
        <dll>gadgetron_mricore</dll>
        <classname>ImageFinishAttribGadgetUSHORT</classname>
    </gadget>

</gadgetronStreamConfiguration>
