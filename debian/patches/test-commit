Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gadgetron (3.1.1-1) trusty; urgency=medium
 .
   * Update the source code.
Author: Dusan Puletic <dusan.puletic@nih.gov>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- gadgetron-3.1.1.orig/apps/gadgetron/CMakeLists.txt
+++ gadgetron-3.1.1/apps/gadgetron/CMakeLists.txt
@@ -72,6 +72,7 @@ target_link_libraries(gadgetron_gadgetba
   gadgetron_toolbox_log
 )
 
+set_target_properties(gadgetron_gadgetbase PROPERTIES VERSION ${GADGETRON_VERSION_STRING} SOVERSION ${GADGETRON_SOVERSION})
 set_target_properties (gadgetron_gadgetbase PROPERTIES COMPILE_DEFINITIONS "__BUILD_GADGETRON_GADGETBASE__")
 
 install(TARGETS gadgetron gadgetron_info DESTINATION bin COMPONENT main)
--- gadgetron-3.1.1.orig/chroot/CMakeLists.txt
+++ gadgetron-3.1.1/chroot/CMakeLists.txt
@@ -95,7 +95,7 @@ add_custom_command(
   ${LIBRARY_PATHS}
   )
 
-set(PACKAGES_PATH "/home/ubuntu/packages/no_components")
+set(PACKAGES_PATH "/home/ubuntu/gadgetron-deb-bucket/yes-components")
 
 add_custom_command(
   TARGET chroot-local
--- gadgetron-3.1.1.orig/chroot/create_chroot.sh
+++ gadgetron-3.1.1/chroot/create_chroot.sh
@@ -36,15 +36,8 @@ else
     if [ $# -eq 5 ]; then
       PACKAGES_PATH=${5}
       echo PACKAGES_PATH: ${PACKAGES_PATH}
-      cp ${PACKAGES_PATH}/*.deb ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/
-      OPENBLAS_PACKAGE=$(basename ${PACKAGES_PATH}/*openblas*.deb)
-      echo "OPENBLAS_PACKAGE: ${OPENBLAS_PACKAGE}"
-      ISMRMRD_PACKAGE=$(basename ${PACKAGES_PATH}/ismrmrd*.deb)
-      echo "ISMRMRD_PACKAGE: ${ISMRMRD_PACKAGE}"
-      CONVERTER_PACKAGE=$(basename ${PACKAGES_PATH}/*siemens*.deb)
-      echo "CONVERTER_PACKAGE: ${CONVERTER_PACKAGE}"
-      GADGETRON_PACKAGE=$(basename ${PACKAGES_PATH}/*gadgetron*.deb)
-      echo "GADGETRON_PACKAGE: ${GADGETRON_PACKAGE}"
+      mkdir -p ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/debian/
+      cp ${PACKAGES_PATH}/*.deb ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/debian
     fi
 
     mkdir -p ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-backups
@@ -55,37 +48,44 @@ else
 
     chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron apt-get --yes install software-properties-common
 
-    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://us-east-1.ec2.archive.ubuntu.com/ubuntu/ trusty restricted main multiverse universe"
-    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://us-east-1.ec2.archive.ubuntu.com/ubuntu/ trusty-updates universe restricted multiverse main"
-    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://security.ubuntu.com/ubuntu trusty-security main universe"
-    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://gb.archive.ubuntu.com/ubuntu trusty main"
+    # Update sources.list files with the local folder
+    if [ $# -eq 5 ]; then
+      cd ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/debian
+      dpkg-scanpackages . /dev/null | gzip -9c > Packages.gz
+      sed -i '1s;^;deb file:/debian ./\n;' ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/etc/apt/sources.list
+    fi
 
+    # Update sources.list files with the AWS s3 bucket
     if [ $# -eq 4 ]; then
       chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://gadgetronubuntu.s3.amazonaws.com trusty main"
     fi
 
+    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://us-east-1.ec2.archive.ubuntu.com/ubuntu/ trusty restricted main multiverse universe"
+    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://us-east-1.ec2.archive.ubuntu.com/ubuntu/ trusty-updates universe restricted multiverse main"
+    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://security.ubuntu.com/ubuntu trusty-security main universe"
+    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron add-apt-repository "deb http://gb.archive.ubuntu.com/ubuntu trusty main"
+
     chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron apt-get update
-    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron apt-get --yes install sudo python-dev python-twisted python-psutil python-numpy python-h5py gdebi-core
+    chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron apt-get --yes install sudo build-essential python-dev python-twisted python-psutil python-numpy python-h5py gdebi-core libxml2-dev
 
     if [ $# -eq 4 ]; then
       chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron apt-get --yes --force-yes install libopenblas-base ismrmrd siemens-to-ismrmrd gadgetron
+      cp -n ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron${CHROOT_GADGETRON_INSTALL_PREFIX}/config/gadgetron.xml.example ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron${CHROOT_GADGETRON_INSTALL_PREFIX}/config/gadgetron.xml
     fi
 
     if [ $# -eq 5 ]; then
-      chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron gdebi $OPENBLAS_PACKAGE
-      chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron gdebi $ISMRMRD_PACKAGE
-      chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron gdebi $CONVERTER_PACKAGE
-      chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron gdebi $GADGETRON_PACKAGE
+      for package in ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/debian/*.deb;
+	do chroot ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron gdebi "/debian/$(basename ${package})";
+      done
+      cp -n ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/usr/gadgetron/config/gadgetron.xml.example ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron/usr/gadgetron/config/gadgetron.xml
     fi
 
-    cp -n ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron${CHROOT_GADGETRON_INSTALL_PREFIX}/config/gadgetron.xml.example ${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-root/gadgetron${CHROOT_GADGETRON_INSTALL_PREFIX}/config/gadgetron.xml
-
     TAR_FILE_NAME=gadgetron-`date '+%Y%m%d-%H%M'`-${CHROOT_GIT_SHA1_HASH:0:8}
     IMAGE_FILE_NAME=${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-backups/${TAR_FILE_NAME}.img
 
     tar -zcf "${CHROOT_GADGETRON_BINARY_DIR}/chroot/chroot-backups/${TAR_FILE_NAME}.tar.gz" --directory "${CHROOT_GADGETRON_BINARY_DIR}/chroot" --exclude=./chroot-root/gadgetron/dev --exclude=./chroot-root/gadgetron/sys --exclude=./chroot-root/gadgetron/proc --exclude=./chroot-root/gadgetron/root ./chroot-root
 
-    dd if=/dev/zero of=${IMAGE_FILE_NAME} bs=2048k seek=1024 count=0
+    dd if=/dev/zero of=${IMAGE_FILE_NAME} bs=3072k seek=1024 count=0
     mke2fs -F -t ext3 ${IMAGE_FILE_NAME}
     mkdir ${CHROOT_GADGETRON_BINARY_DIR}/chroot/gadgetron_root
     mount -o loop ${IMAGE_FILE_NAME} ${CHROOT_GADGETRON_BINARY_DIR}/chroot/gadgetron_root
--- gadgetron-3.1.1.orig/test/hoNDArray_utils_test.cpp
+++ gadgetron-3.1.1/test/hoNDArray_utils_test.cpp
@@ -1,6 +1,7 @@
 #include "hoNDArray_utils.h"
 #include "hoNDArray_elemwise.h"
 #include "complext.h"
+#include "GadgetronTimer.h"
 
 #include <gtest/gtest.h>
 #include <complex>
@@ -126,6 +127,18 @@ TYPED_TEST(hoNDArray_utils_TestCplx,perm
 
   EXPECT_FLOAT_EQ(2, real(permute(&this->Array,&order)->at(851)));
   EXPECT_FLOAT_EQ(3, imag(permute(&this->Array,&order)->at(851)));
+
+  order.clear();
+  order.push_back(0); order.push_back(1); order.push_back(3); order.push_back(2);
+
+  EXPECT_FLOAT_EQ(2, real(permute(&this->Array, &order)->at(37)));
+  EXPECT_FLOAT_EQ(3, imag(permute(&this->Array, &order)->at(37)));
+
+  order.clear();
+  order.push_back(0); order.push_back(2); order.push_back(3); order.push_back(1);
+
+  EXPECT_FLOAT_EQ(2, real(permute(&this->Array, &order)->at(37*23*19)));
+  EXPECT_FLOAT_EQ(3, imag(permute(&this->Array, &order)->at(37*23*19)));
 }
 
 TYPED_TEST(hoNDArray_utils_TestCplx,shiftDimTest){
--- gadgetron-3.1.1.orig/test/integration/data.txt
+++ gadgetron-3.1.1/test/integration/data.txt
@@ -7,6 +7,7 @@ radial_phantom/meas_MID00135_FID20082_CV
 rtgrappa/acc_data_with_device_2.dat: ac0b59c6c8989c94738e41e2c4b5ec13
 rtgrappa/grappa_rate2_out_20150110_msh.h5: 53268231efa796ce2315edc272e81e3a
 simple_gre/meas_MiniGadgetron_GRE.dat: 7c5c255522e42367546b4045560afcf8
+simple_gre/simple_gre_out.h5: 624ac3178e15e27e52489f330b3fffa5
 simple_gre/simple_gre_out_20150110_msh.h5: 13870af335ec1708a15fc139d0ffd4bb
 spiral/simple_spiral_out.h5: 44be83612c69f008ee71a47fecd3c7ed
 spiral/meas_MID1132_MiniIRT_spiral_16int_tr500_acc1_10reps_FID13142.dat: 763baf3d7d0acff185ec9a3c85d5a3f3
--- /dev/null
+++ gadgetron-3.1.1/test/integration/test_cases.txt
@@ -0,0 +1,30 @@
+./cases/gtplus_FetalHASTE.cfg
+./cases/gpu_grappa_simple.cfg
+./cases/gtplus_snr_unit_recon_prospective_cine.cfg
+./cases/gtplus_snr_unit_recon_spat3.cfg
+./cases/gpu_fixed_radial_mode1_ktsense.cfg
+./cases/gtplus_FatWater.cfg
+./cases/gtplus_snr_unit_recon_tpat3.cfg
+./cases/simple_gre_3d.cfg
+./cases/gpu_spiral.cfg
+./cases/gtplus_3D_head.cfg
+./cases/gtplus_molli.cfg
+./cases/gtplus_Perfusion.cfg
+./cases/gtplus_snr_unit_recon_ipat4.cfg
+./cases/gtplus_LGE.cfg
+./cases/simple_gre.cfg
+./cases/gtplus_sasha.cfg
+./cases/gtplus_localizer.cfg
+./cases/gpu_golden_radial_mode2_sb.cfg
+./cases/gpu_fixed_radial_mode1_cg.cfg
+./cases/gtplus_T2W.cfg
+./cases/gpu_golden_radial_mode2_realtime.cfg
+./cases/gtplus_snr_unit_recon_builtin_noise.cfg
+./cases/gtplus_snr_unit_recon_spat2_asym_pf.cfg
+./cases/gtplus_real_time_cine.cfg
+./cases/gpu_golden_radial_mode2_ktsense.cfg
+./cases/simple_gre_python.cfg
+./cases/gpu_fixed_radial_mode1_realtime.cfg
+./cases/gpu_spiral_sb.cfg
+./cases/gtplus_real_time_cine_9slices.cfg
+./cases/gpu_golden_radial_mode2_cg.cfg
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/core/core_defines.h
@@ -0,0 +1,28 @@
+/** \file core_defines.h
+    \brief Autogenerated header providing definitions of __host__, __device__, and __inline__ for systems on which Cuda is not installed.
+*/
+
+#pragma once
+
+// Notice:
+// -------
+//
+// The header cpucore_defines.h is autogenerated 
+// by cmake from cpucore_defines.h.in
+//
+
+// Definition of Cuda availability passed to C++
+//
+
+#define GADGETRON_CUDA_IS_AVAILABLE 1
+
+// Used Cuda host definitions if availble.
+// Otherwise we leave them empty (as no device code is compiled anyway).
+
+#if GADGETRON_CUDA_IS_AVAILABLE
+#include "host_defines.h"
+#else
+#define __host__
+#define __device__
+#define __inline__ inline
+#endif
--- gadgetron-3.1.1.orig/toolboxes/core/cpu/hoNDArray_utils.h
+++ gadgetron-3.1.1/toolboxes/core/cpu/hoNDArray_utils.h
@@ -158,13 +158,68 @@ namespace Gadgetron {
 
     T* o = out->get_data_ptr();
 
-    ArrayIterator it(in->get_dimensions().get(),&dim_order_int);
-    for (size_t i = 0; i < in->get_number_of_elements(); i++) {
-      o[i] = in->get_data_ptr()[it.get_current_idx()];
-      it.advance();
+    // if memcpy can be used during permute
+    size_t stride = 1;
+    size_t num_dim_memcpy = 0;
+    for (size_t i = 0; i < dim_order_int.size(); i++) {
+        if (dim_order_int[i]==i){
+            stride *= in->get_size(i);
+            num_dim_memcpy = i;
+        }
+        else{
+            break;
+        }
+    }
+
+    if (stride == 1) {
+        // point by point assignment is needed
+        ArrayIterator it(in->get_dimensions().get(), &dim_order_int);
+        for (size_t i = 0; i < in->get_number_of_elements(); i++) {
+            o[i] = in->get_data_ptr()[it.get_current_idx()];
+            it.advance();
+        }
+    }
+    else {
+        // memcpy can be used
+
+        size_t nDim = in->get_number_of_dimensions();
+        size_t num_memcpy = in->get_number_of_elements() / stride;
+
+        if (num_dim_memcpy == nDim - 1){
+            memcpy(out->begin(), in->begin(), in->get_number_of_bytes());
+            return;
+        }
+
+        // for the array index calculation
+        std::vector<size_t> dim_permute(nDim-num_dim_memcpy-1);
+        for (size_t i = num_dim_memcpy+1; i < dim_order_int.size(); i++) {
+            dim_permute[i - num_dim_memcpy - 1] = in->get_size(i);
+        }
+
+        long long n;
+
+        hoNDArray<T> permuteArray(dim_permute, in->begin(), false);
+
+        // starting index for in and out array for every permute memcpy operation
+        std::vector<size_t> ind_permute_in(dim_permute.size(), 0), ind_in(nDim, 0), ind_out(nDim, 0);
+
+        for (n = 0; n < num_memcpy; n++) {
+            permuteArray.calculate_index(n, ind_permute_in);
+            memcpy(&ind_in[0] + num_dim_memcpy + 1, &ind_permute_in[0], sizeof(size_t)*ind_permute_in.size());
+
+            // permute the indexes
+            for (size_t i = 0; i < nDim; i++) {
+                ind_out[i] = ind_in[dim_order_int[i]];
+            }
+
+            size_t offset_in = in->calculate_offset(ind_in);
+            size_t offset_out = out->calculate_offset(ind_out);
+
+            memcpy(o + offset_out, in->begin() + offset_in, sizeof(T)*stride);
+        }
     }
   }
-   
+
   // Expand array to new dimension
   template<class T> boost::shared_ptr<hoNDArray<T> > 
   expand(hoNDArray<T> *in, size_t new_dim_size )
@@ -172,14 +227,14 @@ namespace Gadgetron {
     if( in == 0x0 ){
       throw std::runtime_error("expand(): illegal input pointer.");;
     }
-      
+
     const size_t number_of_elements_in = in->get_number_of_elements();    
 
     std::vector<size_t> dims = *in->get_dimensions(); 
     dims.push_back(new_dim_size);
 
     boost::shared_ptr< hoNDArray<T> > out(new hoNDArray<T>(&dims));
-      
+
 #ifdef USE_OMP
 #pragma omp parallel for
 #endif
--- gadgetron-3.1.1.orig/toolboxes/core/cpu/math/hoNDArray_elemwise.cpp
+++ gadgetron-3.1.1/toolboxes/core/cpu/math/hoNDArray_elemwise.cpp
@@ -2407,6 +2407,106 @@ namespace Gadgetron{
 
     // --------------------------------------------------------------------------------
 
+    template <typename T> 
+    void sum_over_dimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t dim)
+    {
+        try
+        {
+            size_t D = x.get_number_of_dimensions();
+            if (dim >= D)
+            {
+                r = x;
+                return;
+            }
+
+            std::vector<size_t> dimX, dimR;
+            x.get_dimensions(dimX);
+
+            dimR = dimX;
+            dimR[dim] = 1;
+
+            if (!r.dimensions_equal(&dimR))
+            {
+                r.create(dimR);
+            }
+
+            if (dim == 0)
+            {
+                size_t X = x.get_size(0);
+                size_t num = x.get_number_of_elements() / X;
+
+                const T* pX = x.begin();
+                T* pR = r.begin();
+
+                long long n;
+
+                #pragma omp parallel for default(none) private(n) shared(X, num, pX, pR)
+                for (n = 0; n<(long long)num; n++)
+                {
+                    T xsum = pX[n*X];
+                    for (size_t ro = 1; ro<X; ro++)
+                    {
+                        xsum += pX[n*X + ro];
+                    }
+
+                    pR[n] = xsum;
+                }
+            }
+            else
+            {
+                size_t strideX = x.get_size(0);
+                for (size_t d = 1; d <= dim; d++)
+                {
+                    strideX *= x.get_size(d);
+                }
+
+                size_t strideR = strideX / x.get_size(dim);
+                size_t num = x.get_number_of_elements() / strideX;
+                size_t nDim = x.get_size(dim);
+
+                const T* pX = x.begin();
+                T* pR = r.begin();
+
+                if (nDim == 1)
+                {
+                    memcpy(pR, pX, x.get_number_of_bytes());
+                    return;
+                }
+
+                long long n;
+
+                #pragma omp parallel for default(none) private(n) shared(strideX, strideR, num, nDim, pX, pR)
+                for (n = 0; n<(long long)num; n++)
+                {
+                    const T* pX_curr = pX + n*strideX;
+                    T* pR_curr = pR + n*strideR;
+
+                    memcpy(pR_curr, pX_curr, sizeof(T)*strideR);
+
+                    size_t p, c;
+                    for (p = 1; p<nDim; p++)
+                    {
+                        for (c = 0; c < strideR; c++)
+                        {
+                            pR_curr[c] += pX_curr[p*strideR+c];
+                        }
+                    }
+                }
+            }
+        }
+        catch (...)
+        {
+            GADGET_THROW("Errors happened in sum_over_dimension(const hoNDArray<T>& x, hoNDArray<T>& y, size_t dim) ... ");
+        }
+    }
+
+    template EXPORTCPUCOREMATH void sum_over_dimension(const hoNDArray<float>& x, hoNDArray<float>& y, size_t dim);
+    template EXPORTCPUCOREMATH void sum_over_dimension(const hoNDArray<double>& x, hoNDArray<double>& y, size_t dim);
+    template EXPORTCPUCOREMATH void sum_over_dimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& y, size_t dim);
+    template EXPORTCPUCOREMATH void sum_over_dimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& y, size_t dim);
+
+    // --------------------------------------------------------------------------------
+
     template<class T> hoNDArray<T>& operator+= (hoNDArray<T> &x, const T &y)
     {
         /*arma::Col<typename stdType<T>::Type> aRes = as_arma_col(&x);
--- gadgetron-3.1.1.orig/toolboxes/core/cpu/math/hoNDArray_elemwise.h
+++ gadgetron-3.1.1/toolboxes/core/cpu/math/hoNDArray_elemwise.h
@@ -683,4 +683,12 @@ void conv2(const hoNDArray<T>& x, const
 template <typename T> EXPORTCPUCOREMATH 
 void conv3(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& z);
 
+/**
+* @brief sum over a specific dimension
+            x: input array, y: output array, dim: dimension to perform sum
+            resulting y.get_size(d) == 1
+*/
+template <typename T> EXPORTCPUCOREMATH
+void sum_over_dimension(const hoNDArray<T>& x, hoNDArray<T>& y, size_t dim);
+
 }
--- gadgetron-3.1.1.orig/toolboxes/ct/xray/gpu/hoCuConebeamProjectionOperator.h
+++ gadgetron-3.1.1/toolboxes/ct/xray/gpu/hoCuConebeamProjectionOperator.h
@@ -125,10 +125,7 @@ namespace Gadgetron{
       return binning_;
     }
     
-    virtual boost::shared_ptr< linearOperator< hoCuNDArray<float> > > clone() {
-      return linearOperator< hoCuNDArray<float> >::clone(this);
-    }
-    
+
   protected:
     virtual void compute_default_frequency_filter();
     virtual void compute_cosine_weights();
--- gadgetron-3.1.1.orig/toolboxes/dwt/gpu/cuDWTOperator.h
+++ gadgetron-3.1.1/toolboxes/dwt/gpu/cuDWTOperator.h
@@ -102,10 +102,6 @@ public:
 	static auto haahr = vector_td<typename realType<T>::Type,2>{1.0f,1.0f};
 	static auto daubechies6= vector_td<typename realType<T>::Type,6>{0.47046721f,1.14111692f,0.650365f,-0.19093442f, -0.12083221f,0.0498175f};
 	*/
-	virtual boost::shared_ptr< linearOperator< cuNDArray<T> > > clone()
-    										{
-		return linearOperator<cuNDArray<T>>::clone(this);
-    										}
 
 
 private:
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusGRAPPA.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusGRAPPA.h
@@ -489,46 +489,48 @@ calib3D(const ho4DArray<T>& acsSrc, cons
                 hoNDArray<T> acsSrc1stCha(RO, E1, E2, const_cast<T*>(acsSrc.begin()));
                 hoNDArray<T> acsSrc1stChaSumE2(RO, E1, 1), acsSrc1stChaSumE2E1(RO, 1, 1);
 
-                if ( Gadgetron::sumOver3rdDimension(acsSrc1stCha, acsSrc1stChaSumE2) )
+                try
                 {
-                    if ( Gadgetron::sumOver2ndDimension(acsSrc1stChaSumE2, acsSrc1stChaSumE2E1) )
-                    {
-                        T maxSignal;
-                        size_t roInd(0);
-                        try
-                        {
-                            Gadgetron::maxAbsolute(acsSrc1stChaSumE2E1, maxSignal, roInd);
+                    Gadgetron::sum_over_dimension(acsSrc1stCha, acsSrc1stChaSumE2, 2);
+                    Gadgetron::sum_over_dimension(acsSrc1stChaSumE2, acsSrc1stChaSumE2E1, 1);
 
-                            if ( roInd > maxROUsed/2+kROhalf )
-                            {
-                                sRO = roInd - maxROUsed/2;
-                            }
-                            else
-                            {
-                                sRO = kROhalf;
-                            }
+                    T maxSignal;
+                    size_t roInd(0);
+                    try
+                    {
+                        Gadgetron::maxAbsolute(acsSrc1stChaSumE2E1, maxSignal, roInd);
 
-                            if( sRO+maxROUsed-1 <= RO-kROhalf-1 )
-                            {
-                                eRO = sRO + maxROUsed - 1;
-                            }
-                            else
-                            {
-                                eRO = RO - kROhalf -1;
-                            }
+                        if ( roInd > maxROUsed/2+kROhalf )
+                        {
+                            sRO = roInd - maxROUsed/2;
+                        }
+                        else
+                        {
+                            sRO = kROhalf;
+                        }
 
-                            lenRO = eRO-sRO+1;
-                            GDEBUG_STREAM("gtPlusGRAPPA<T>::calib3D(...) - overDetermineRatio = " << overDetermineRatio << " ; RO data range used : [" << sRO << " " << eRO << "] ...");
+                        if( sRO+maxROUsed-1 <= RO-kROhalf-1 )
+                        {
+                            eRO = sRO + maxROUsed - 1;
                         }
-                        catch(...)
+                        else
                         {
-                            GWARN_STREAM("gtPlusGRAPPA<T>::calib3D(...) - overDetermineRatio is ignored ... ");
+                            eRO = RO - kROhalf -1;
                         }
+
+                        lenRO = eRO-sRO+1;
+                        GDEBUG_STREAM("gtPlusGRAPPA<T>::calib3D(...) - overDetermineRatio = " << overDetermineRatio << " ; RO data range used : [" << sRO << " " << eRO << "] ...");
+                    }
+                    catch(...)
+                    {
+                        GWARN_STREAM("gtPlusGRAPPA<T>::calib3D(...) - overDetermineRatio is ignored ... ");
+                        throw;
                     }
                 }
-                else
+                catch (...)
                 {
                     GWARN_STREAM("gtPlusGRAPPA<T>::calib3D(...) - overDetermineRatio is ignored ... ");
+                    throw;
                 }
             }
         }
@@ -933,7 +935,14 @@ imageDomainKernelRO3D(const ho7DArray<T>
         if ( performTiming_ ) { gt_timer3_.stop(); }
 
         if ( performTiming_ ) { gt_timer3_.start("grappa 3D calibration - permute kernel dimensions to be [kE1 kE2 RO ...]  ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo3rdDimensionFor3DRecon(kImROTemp, kImRO));
+
+        std::vector<size_t> dim_order(3);
+        dim_order[0] = 1;
+        dim_order[1] = 2;
+        dim_order[2] = 0;
+
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&kImROTemp, &kImRO, &dim_order));
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
     }
     catch(...)
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusOperator.h
@@ -106,6 +106,8 @@ public:
     hoNDArrayMemoryManaged<T> complexIm_Managed_;
     hoNDArrayMemoryManaged<T> res_after_apply_kernel_Managed_;
     hoNDArrayMemoryManaged<T> res_after_apply_kernel_sum_over_Managed_;
+
+    bool performSumOverSrcChannel(const hoNDArray<T>& x, hoNDArray<T>& r);
 };
 
 template <typename T> 
@@ -255,4 +257,49 @@ proximity(hoNDArray<T>& /*x*/, value_typ
     return true;
 }
 
+template<typename T>
+bool gtPlusOperator<T>::
+performSumOverSrcChannel(const hoNDArray<T>& x, hoNDArray<T>& r)
+{
+    try
+    {
+        boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
+        size_t NDim = dim->size();
+
+        if (NDim < 2) return true;
+
+        std::vector<size_t> dimR(NDim - 1);
+        std::vector<size_t> dimRInternal = *dim;
+        dimRInternal[NDim - 2] = 1;
+
+        size_t d;
+        for (d = 0; d<NDim - 2; d++)
+        {
+            dimR[d] = (*dim)[d];
+        }
+        dimR[NDim - 2] = (*dim)[NDim - 1];
+
+        if (!r.dimensions_equal(&dimR))
+        {
+            r.create(&dimR);
+        }
+
+        if (x.get_size(NDim - 2) <= 1)
+        {
+            memcpy(r.begin(), x.begin(), x.get_number_of_bytes());
+            return true;
+        }
+
+        hoNDArray<T> rSum(dimRInternal, r.begin());
+
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(x, rSum, NDim - 2));
+    }
+    catch (...)
+    {
+        GERROR_STREAM("Errors in performSumOverSrcChannel(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
+        return false;
+    }
+    return true;
+}
+
 }}
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusSPIRIT.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusSPIRIT.h
@@ -391,9 +391,13 @@ imageDomainKernel(const ho6DArray<T>& ke
         }
 
         hoNDArray<T> convKer2;
-        ho4DArray<T> conKerMean(convKRO, convKE1, srcCHA, dstCHA);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer, convKer2));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer2, conKerMean));
+        hoNDArray<T> conKerMean(convKRO, convKE1, srcCHA, dstCHA, 1, 1);
+
+        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer, convKer2));
+        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer2, conKerMean));
+
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(convKer, convKer2, 5));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(convKer2, conKerMean, 4));
         GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::scal( (typename realType<T>::Type)(1.0/(oRO*oE1)), conKerMean) );
 
         // flip the kernel
@@ -407,7 +411,7 @@ imageDomainKernel(const ho6DArray<T>& ke
                 {
                     for ( src=0; src<srcCHA; src++ )
                     {
-                        convKerFlip( kro, ke1, src, dst) = conKerMean(convKRO-1-kro, convKE1-1-ke1, src, dst);
+                        convKerFlip( kro, ke1, src, dst) = conKerMean(convKRO-1-kro, convKE1-1-ke1, src, dst, 0, 0);
                     }
                 }
             }
@@ -529,46 +533,48 @@ calib3D(const ho4DArray<T>& acsSrc, cons
                 hoNDArray<T> acsSrc1stCha(RO, E1, E2, const_cast<T*>(acsSrc.begin()));
                 hoNDArray<T> acsSrc1stChaSumE2(RO, E1, 1), acsSrc1stChaSumE2E1(RO, 1, 1);
 
-                if ( Gadgetron::sumOver3rdDimension(acsSrc1stCha, acsSrc1stChaSumE2) )
+                try
                 {
-                    if ( Gadgetron::sumOver2ndDimension(acsSrc1stChaSumE2, acsSrc1stChaSumE2E1) )
-                    {
-                        T maxSignal;
-                        size_t roInd(0);
-                        try
-                        {
-                            Gadgetron::maxAbsolute(acsSrc1stChaSumE2E1, maxSignal, roInd);
+                    Gadgetron::sum_over_dimension(acsSrc1stCha, acsSrc1stChaSumE2, 2);
+                    Gadgetron::sum_over_dimension(acsSrc1stChaSumE2, acsSrc1stChaSumE2E1, 1);
 
-                            if ( roInd > maxROUsed/2+kROhalf )
-                            {
-                                sRO = roInd - maxROUsed/2;
-                            }
-                            else
-                            {
-                                sRO = kROhalf;
-                            }
+                    T maxSignal;
+                    size_t roInd(0);
+                    try
+                    {
+                        Gadgetron::maxAbsolute(acsSrc1stChaSumE2E1, maxSignal, roInd);
 
-                            if( sRO+maxROUsed-1 <= RO-kROhalf-1 )
-                            {
-                                eRO = sRO + maxROUsed - 1;
-                            }
-                            else
-                            {
-                                eRO = RO - kROhalf -1;
-                            }
+                        if ( roInd > maxROUsed/2+kROhalf )
+                        {
+                            sRO = roInd - maxROUsed/2;
+                        }
+                        else
+                        {
+                            sRO = kROhalf;
+                        }
 
-                            lenRO = eRO-sRO+1;
-                            GDEBUG_STREAM("gtPlusSPIRIT<T>::calib3D(...) - overDetermineRatio = " << overDetermineRatio << " ; RO data range used : [" << sRO << " " << eRO << "] ...");
+                        if( sRO+maxROUsed-1 <= RO-kROhalf-1 )
+                        {
+                            eRO = sRO + maxROUsed - 1;
                         }
-                        catch(...)
+                        else
                         {
-                            GWARN_STREAM("gtPlusSPIRIT<T>::calib3D(...) - overDetermineRatio is ignored ... ");
+                            eRO = RO - kROhalf -1;
                         }
+
+                        lenRO = eRO-sRO+1;
+                        GDEBUG_STREAM("gtPlusSPIRIT<T>::calib3D(...) - overDetermineRatio = " << overDetermineRatio << " ; RO data range used : [" << sRO << " " << eRO << "] ...");
+                    }
+                    catch(...)
+                    {
+                        GWARN_STREAM("gtPlusSPIRIT<T>::calib3D(...) - overDetermineRatio is ignored ... ");
+                        throw;
                     }
                 }
-                else
+                catch (...)
                 {
                     GWARN_STREAM("gtPlusSPIRIT<T>::calib3D(...) - overDetermineRatio is ignored ... ");
+                    throw;
                 }
             }
         }
@@ -866,10 +872,17 @@ kspaceDomainConvKernel3D(const hoNDArray
 
         if ( performTiming_ ) { gt_timer3_.start("spirit 3D calibration - sum over output dimensions ... "); }
         hoNDArray<T> convKer2, convKer3;
-        ho5DArray<T> convKernMean(convKRO, convKE1, convKE2, srcCHA, dstCHA);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer, convKer2));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer2, convKer3));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer3, convKernMean));
+
+        //ho5DArray<T> convKernMean(convKRO, convKE1, convKE2, srcCHA, dstCHA);
+        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer, convKer2));
+        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer2, convKer3));
+        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(convKer3, convKernMean));
+
+        hoNDArray<T> convKernMean(convKRO, convKE1, convKE2, srcCHA, dstCHA, 1, 1, 1);
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(convKer, convKer2, 7));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(convKer2, convKer3, 6));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(convKer3, convKernMean, 5));
+
         GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::scal( (typename realType<T>::Type)(1.0/(oRO*oE1*oE2)), convKernMean) );
         if ( performTiming_ ) { gt_timer3_.stop(); }
 
@@ -893,7 +906,7 @@ kspaceDomainConvKernel3D(const hoNDArray
                         {
                             for ( src=0; src<srcCHA; src++ )
                             {
-                                T value = convKernMean(convKRO-1-kro, convKE1-1-ke1, convKE2-1-ke2, src, dst);
+                                T value = convKernMean(convKRO-1-kro, convKE1-1-ke1, convKE2-1-ke2, src, dst, 0, 0, 0);
                                 convKerFlip(ke1, ke2, kro, src, dst) = value;
                             }
                         }
@@ -1060,7 +1073,14 @@ imageDomainKernelRO3D(const hoNDArray<T>
         if ( performTiming_ ) { gt_timer3_.stop(); }
 
         if ( performTiming_ ) { gt_timer3_.start("spirit 3D calibration - permute kernel dimensions to be [kE1 kE2 RO ...]  ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo3rdDimensionFor3DRecon(kImROTemp, kImRO));
+
+        std::vector<size_t> dim_order(3);
+        dim_order[0] = 1;
+        dim_order[1] = 2;
+        dim_order[2] = 0;
+
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&kImROTemp, &kImRO, &dim_order));
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
     }
     catch(...)
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusSPIRIT2DOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusSPIRIT2DOperator.h
@@ -177,9 +177,6 @@ inline bool gtPlusSPIRIT2DOperator<T>::a
             this->convertToImage(x, complexIm_);
 
             // apply kernel and sum
-            //Gadgetron::multipleMultiply(complexIm_, *adjoint_kernel_, res_after_apply_kernel_);
-            //Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_);
-
             size_t ro = x.get_size(0);
             size_t e1 = x.get_size(1);
             size_t CHA = x.get_size(2);
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusSPIRIT2DTOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusSPIRIT2DTOperator.h
@@ -253,10 +253,10 @@ bool gtPlusSPIRIT2DTOperator<T>::grad(co
                 curr_adjoint_forward_kernel.create(RO, E1, CHA, dstCHA, this->adjoint_forward_kernel_->begin()+(kernelN-1)*RO*E1*CHA*dstCHA);
             }
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(currComplexIm, curr_adjoint_forward_kernel, this->res_after_apply_kernel_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(curr_adjoint_forward_kernel, currComplexIm, this->res_after_apply_kernel_));
 
-            hoNDArray<T> sumResCurr(RO, E1, dstCHA, this->res_after_apply_kernel_sum_over_.begin()+n*RO*E1*dstCHA);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(this->res_after_apply_kernel_, sumResCurr));
+            hoNDArray<T> sumResCurr(RO, E1, 1, dstCHA, this->res_after_apply_kernel_sum_over_.begin() + n*RO*E1*dstCHA);
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(this->res_after_apply_kernel_, sumResCurr, 2));
         }
 
         //gt_timer1_.stop();
@@ -332,10 +332,10 @@ bool gtPlusSPIRIT2DTOperator<T>::obj(con
                 curr_forward_kernel.create(RO, E1, CHA, dstCHA, this->forward_kernel_->begin()+(kernelN-1)*RO*E1*CHA*dstCHA);
             }
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(currComplexIm, curr_forward_kernel, this->res_after_apply_kernel_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(curr_forward_kernel, currComplexIm, this->res_after_apply_kernel_));
 
-            hoNDArray<T> sumResCurr(RO, E1, dstCHA, this->res_after_apply_kernel_sum_over_.begin()+n*RO*E1*dstCHA);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(this->res_after_apply_kernel_, sumResCurr));
+            hoNDArray<T> sumResCurr(RO, E1, 1, dstCHA, this->res_after_apply_kernel_sum_over_.begin() + n*RO*E1*dstCHA);
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(this->res_after_apply_kernel_, sumResCurr, 2));
         }
 
         // L2 norm
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusSPIRITNoNullSpace2DTOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusSPIRITNoNullSpace2DTOperator.h
@@ -205,10 +205,10 @@ bool gtPlusSPIRITNoNullSpace2DTOperator<
                 curr_adjoint_forward_kernel.create(RO, E1, CHA, dstCHA, this->adjoint_forward_kernel_->begin()+(kernelN-1)*RO*E1*CHA*dstCHA);
             }
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(currComplexIm, curr_adjoint_forward_kernel, this->res_after_apply_kernel_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(curr_adjoint_forward_kernel, currComplexIm, this->res_after_apply_kernel_));
 
-            hoNDArray<T> sumResCurr(RO, E1, dstCHA, this->res_after_apply_kernel_sum_over_.begin()+n*RO*E1*dstCHA);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(this->res_after_apply_kernel_, sumResCurr));
+            hoNDArray<T> sumResCurr(RO, E1, 1, dstCHA, this->res_after_apply_kernel_sum_over_.begin() + n*RO*E1*dstCHA);
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(this->res_after_apply_kernel_, sumResCurr, 2));
         }
 
         // go back to kspace 
@@ -264,10 +264,10 @@ bool gtPlusSPIRITNoNullSpace2DTOperator<
                 curr_forward_kernel.create(RO, E1, CHA, dstCHA, this->forward_kernel_->begin()+(kernelN-1)*RO*E1*CHA*dstCHA);
             }
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(currComplexIm, curr_forward_kernel, this->res_after_apply_kernel_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(curr_forward_kernel, currComplexIm, this->res_after_apply_kernel_));
 
-            hoNDArray<T> sumResCurr(RO, E1, dstCHA, this->res_after_apply_kernel_sum_over_.begin()+n*RO*E1*dstCHA);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(this->res_after_apply_kernel_, sumResCurr));
+            hoNDArray<T> sumResCurr(RO, E1, 1, dstCHA, this->res_after_apply_kernel_sum_over_.begin() + n*RO*E1*dstCHA);
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(this->res_after_apply_kernel_, sumResCurr, 2));
         }
 
         // L2 norm
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusSPIRITNoNullSpaceOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusSPIRITNoNullSpaceOperator.h
@@ -82,8 +82,8 @@ bool gtPlusSPIRITNoNullSpaceOperator<T>:
         GADGET_CHECK_RETURN_FALSE(this->convertToImage(x, this->complexIm_));
 
         // apply kernel and sum
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(this->complexIm_, *this->adjoint_forward_kernel_, this->res_after_apply_kernel_));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(this->res_after_apply_kernel_, this->res_after_apply_kernel_sum_over_));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*this->adjoint_forward_kernel_, this->complexIm_, this->res_after_apply_kernel_));
+        GADGET_CHECK_RETURN_FALSE(this->performSumOverSrcChannel(this->res_after_apply_kernel_, this->res_after_apply_kernel_sum_over_));
 
         // go back to kspace 
         GADGET_CHECK_RETURN_FALSE(this->convertToKSpace(this->res_after_apply_kernel_sum_over_, g));
@@ -112,8 +112,8 @@ bool gtPlusSPIRITNoNullSpaceOperator<T>:
         GADGET_CHECK_RETURN_FALSE(this->convertToImage(x, this->complexIm_));
 
         // apply kernel and sum
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(this->complexIm_, *this->forward_kernel_, this->res_after_apply_kernel_));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(this->res_after_apply_kernel_, this->res_after_apply_kernel_sum_over_));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*this->forward_kernel_, this->complexIm_, this->res_after_apply_kernel_));
+        GADGET_CHECK_RETURN_FALSE(this->performSumOverSrcChannel(this->res_after_apply_kernel_, this->res_after_apply_kernel_sum_over_));
 
         // L2 norm
         Gadgetron::dotc(this->res_after_apply_kernel_sum_over_, this->res_after_apply_kernel_sum_over_, obj);
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusSPIRITOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusSPIRITOperator.h
@@ -209,35 +209,6 @@ bool gtPlusSPIRITOperator<T>::forwardOpe
     {
         // Dc(G-I)'(G-I)Dc'x
 
-        // Dc'x
-        //gt_timer1_.start("1");
-        //GADGET_CHECK_RETURN_FALSE(Gadgetron::multiply(unacquired_points_indicator_, x, y));
-        //gt_timer1_.stop();
-
-        //// x to image domain
-        //gt_timer1_.start("2");
-        //GADGET_CHECK_RETURN_FALSE(this->convertToImage(y, complexIm_));
-        //gt_timer1_.stop();
-
-        //// apply kernel and sum
-        //gt_timer1_.start("3");
-        //GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexIm_, *adjoint_forward_kernel_, res_after_apply_kernel_));
-        //gt_timer1_.stop();
-
-        //gt_timer1_.start("4");
-        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
-        //gt_timer1_.stop();
-
-        //// go back to kspace 
-        //gt_timer1_.start("5");
-        //GADGET_CHECK_RETURN_FALSE(this->convertToKSpace(res_after_apply_kernel_sum_over_, y));
-        //gt_timer1_.stop();
-
-        //// apply Dc
-        //gt_timer1_.start("6");
-        //GADGET_CHECK_RETURN_FALSE(Gadgetron::multiply(unacquired_points_indicator_, y, y));
-        //gt_timer1_.stop();
-
         Gadgetron::multiply(unacquired_points_indicator_, x, y);
 
         // x to image domain
@@ -246,14 +217,14 @@ bool gtPlusSPIRITOperator<T>::forwardOpe
         // apply kernel and sum
         if ( use_symmetric_spirit_ )
         {
-            Gadgetron::multipleMultiply(complexIm_, *adjoint_forward_kernel_, res_after_apply_kernel_);
+            Gadgetron::multiply(*adjoint_forward_kernel_, complexIm_, res_after_apply_kernel_);
         }
         else
         {
-            Gadgetron::multipleMultiply(complexIm_, *forward_kernel_, res_after_apply_kernel_);
+            Gadgetron::multiply(*forward_kernel_, complexIm_, res_after_apply_kernel_);
         }
 
-        Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_);
+        this->performSumOverSrcChannel(res_after_apply_kernel_, res_after_apply_kernel_sum_over_);
 
         // go back to kspace 
         this->convertToKSpace(res_after_apply_kernel_sum_over_, y);
@@ -291,8 +262,8 @@ bool gtPlusSPIRITOperator<T>::adjointOpe
             this->convertToImage(x, complexIm_);
 
             // apply kernel and sum
-            Gadgetron::multipleMultiply(complexIm_, *adjoint_kernel_, res_after_apply_kernel_);
-            Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_);
+            Gadgetron::multiply(*adjoint_kernel_, complexIm_, res_after_apply_kernel_);
+            this->performSumOverSrcChannel(res_after_apply_kernel_, res_after_apply_kernel_sum_over_);
 
             // go back to kspace 
             this->convertToKSpace(res_after_apply_kernel_sum_over_, y);
@@ -325,14 +296,14 @@ bool gtPlusSPIRITOperator<T>::computeRig
         // apply kernel and sum
         if ( use_symmetric_spirit_ )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexIm_, *adjoint_forward_kernel_, res_after_apply_kernel_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*adjoint_forward_kernel_, complexIm_, res_after_apply_kernel_));
         }
         else
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexIm_, *forward_kernel_, res_after_apply_kernel_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*forward_kernel_, complexIm_, res_after_apply_kernel_));
         }
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
+        GADGET_CHECK_RETURN_FALSE(this->performSumOverSrcChannel(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
 
         // go back to kspace 
         GADGET_CHECK_RETURN_FALSE(this->convertToKSpace(res_after_apply_kernel_sum_over_, b));
@@ -371,8 +342,8 @@ bool gtPlusSPIRITOperator<T>::grad(const
         GADGET_CHECK_RETURN_FALSE(this->convertToImage(kspace_, complexIm_));
 
         // apply kernel and sum
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexIm_, *adjoint_forward_kernel_, res_after_apply_kernel_));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*adjoint_forward_kernel_, complexIm_, res_after_apply_kernel_));
+        GADGET_CHECK_RETURN_FALSE(this->performSumOverSrcChannel(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
 
         // go back to kspace 
         GADGET_CHECK_RETURN_FALSE(this->convertToKSpace(res_after_apply_kernel_sum_over_, g));
@@ -408,8 +379,8 @@ bool gtPlusSPIRITOperator<T>::obj(const
         GADGET_CHECK_RETURN_FALSE(this->convertToImage(kspace_, complexIm_));
 
         // apply kernel and sum
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexIm_, *forward_kernel_, res_after_apply_kernel_));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*forward_kernel_, complexIm_, res_after_apply_kernel_));
+        GADGET_CHECK_RETURN_FALSE(this->performSumOverSrcChannel(res_after_apply_kernel_, res_after_apply_kernel_sum_over_));
 
         // L2 norm
         Gadgetron::dotc(res_after_apply_kernel_sum_over_, res_after_apply_kernel_sum_over_, obj);
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusWavelet3DOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusWavelet3DOperator.h
@@ -345,7 +345,7 @@ L1Norm(const hoNDArray<T>& wavCoeff, hoN
         // square the coefficients
         GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiplyConj(wavCoeff, wavCoeff, complexIm_norm_));
         // sum over CHA
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver5thDimension(complexIm_norm_, wavCoeffNorm));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(complexIm_norm_, wavCoeffNorm, 4));
     }
     catch (...)
     {
@@ -397,11 +397,26 @@ divideWavCoeffByNorm(hoNDArray<T>& wavCo
 
         if ( processApproxCoeff )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver5thDimension(wav_coeff_norm_approx_, wavCoeff, wavCoeff));
+            long long num = wavCoeff.get_number_of_elements() / (RO*E1*E2*W*CHA);
+
+            #pragma omp parallel default(none) private(ii) shared(RO, E1, E2, num, wavCoeffNorm, wavCoeff, W, CHA) if ( num > 1 )
+            {
+
+                #pragma omp for
+                for (ii = 0; ii<num; ii++)
+                {
+                    hoNDArray<T> wavCoeffNormCurr(RO, E1, E2, W, wav_coeff_norm_approx_.begin() + ii*RO*E1*E2*W);
+
+                    for (long long cha = 0; cha<CHA; cha++)
+                    {
+                        hoNDArray<T> wavCoeffCurr(RO, E1, E2, W, wavCoeff.begin() + ii*RO*E1*E2*W*CHA + cha*RO*E1*E2*W);
+                        Gadgetron::multiply(wavCoeffNormCurr, wavCoeffCurr, wavCoeffCurr);
+                    }
+                }
+            }
         }
         else
         {
-            // GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver5thDimensionExcept(wav_coeff_norm_approx_, wavCoeff, 0, wavCoeff, true));
             long long num = wavCoeff.get_number_of_elements()/(RO*E1*E2*W*CHA);
 
             #pragma omp parallel default(none) private(ii) shared(RO, E1, E2, num, wavCoeffNorm, wavCoeff, W, CHA) if ( num > 1 )
@@ -491,8 +506,6 @@ shrinkWavCoeff(hoNDArray<T>& wavCoeff, c
             wav_coeff_norm_approx_.create(wavCoeffNorm.get_dimensions());
         }
 
-        // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver5thDimension(wavCoeffNorm, wav_coeff_norm_mag_sumCHA_));
-
         long long ii;
         long long N = (long long)wavCoeffNorm.get_number_of_elements();
         long long N4D = RO*E1*E2*W;
@@ -537,7 +550,25 @@ shrinkWavCoeff(hoNDArray<T>& wavCoeff, c
             }
             else
             {
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver5thDimension(res_after_apply_kernel_, wavCoeff, complexIm_));
+                long long num = wavCoeff.get_number_of_elements() / (RO*E1*E2*W*CHA);
+
+                #pragma omp parallel default(none) private(ii) shared(RO, E1, E2, num, wavCoeff, W, CHA) if ( num > 1 )
+                {
+
+                    #pragma omp for
+                    for (ii = 0; ii<num; ii++)
+                    {
+                        hoNDArray<T> magInvCurr(RO, E1, E2, W, res_after_apply_kernel_.begin() + ii*RO*E1*E2*W);
+
+                        for (long long cha = 0; cha<CHA; cha++)
+                        {
+                            hoNDArray<T> wavCoeffCurr(RO, E1, E2, W, wavCoeff.begin() + ii*RO*E1*E2*W*CHA + cha*RO*E1*E2*W);
+                            hoNDArray<T> resCurr(RO, E1, E2, W, complexIm_.begin() + ii*RO*E1*E2*W*CHA + cha*RO*E1*E2*W);
+
+                            Gadgetron::multiply(magInvCurr, wavCoeffCurr, resCurr);
+                        }
+                    }
+                }
             }
         }
 
@@ -725,13 +756,29 @@ shrinkWavCoeff(hoNDArray<T>& wavCoeff, c
             }
             else
             {
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver5thDimension(wav_coeff_norm_approx_, complexIm_, wavCoeff));
+                long long num = wavCoeff.get_number_of_elements() / (RO*E1*E2*W*CHA);
+
+                #pragma omp parallel default(none) private(ii) shared(RO, E1, E2, num, wavCoeffNorm, wavCoeff, W, CHA) if ( num > 1 )
+                {
+
+                    #pragma omp for
+                    for (ii = 0; ii<num; ii++)
+                    {
+                        hoNDArray<T> magCurr(RO, E1, E2, W, wav_coeff_norm_approx_.begin() + ii*RO*E1*E2*W);
+
+                        for (long long cha = 0; cha<CHA; cha++)
+                        {
+                            hoNDArray<T> phaseCurr(RO, E1, E2, W, complexIm_.begin() + ii*RO*E1*E2*W*CHA + cha*RO*E1*E2*W);
+                            hoNDArray<T> wavCoeffCurr(RO, E1, E2, W, wavCoeff.begin() + ii*RO*E1*E2*W*CHA + cha*RO*E1*E2*W);
+
+                            Gadgetron::multiply(magCurr, phaseCurr, wavCoeffCurr);
+                        }
+                    }
+                }
             }
         }
         else
         {
-            // GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver5thDimensionExcept(wav_coeff_norm_approx_, complexIm_, 0, wavCoeff, false));
-
             if ( wav_coeff_norm_approx_.dimensions_equal(&wavCoeff) )
             {
                 #pragma omp parallel default(none) private(ii) shared(RO, E1, E2, wavCoeffNorm, wavCoeff, W, CHA) if ( CHA > 1 )
@@ -1189,11 +1236,11 @@ gradTask(const hoNDArray<T>& x, hoNDArra
                 if ( coil_senMap_->get_size(3) == E2 )
                 {
                     hoNDArray<T> coilMapE2(RO, E1, CHA, coil_senMap_->begin()+e2*RO*E1*CHA);
-                    GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexImE2, coilMapE2, kspace_wavE2));
+                    GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(coilMapE2, complexImE2, kspace_wavE2));
                 }
                 else
                 {
-                    GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexImE2, *coil_senMap_, kspace_wavE2));
+                    GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*coil_senMap_, complexImE2, kspace_wavE2));
                 }
             }
             //gt_timer2_.stop();
--- gadgetron-3.1.1.orig/toolboxes/gtplus/algorithm/gtPlusWaveletOperator.h
+++ gadgetron-3.1.1/toolboxes/gtplus/algorithm/gtPlusWaveletOperator.h
@@ -212,7 +212,7 @@ L1Norm(const hoNDArray<T>& wavCoeff, hoN
         // square the coefficients
         Gadgetron::multiplyConj(wavCoeff, wavCoeff, complexIm_norm_);
         // sum over CHA
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(complexIm_norm_, wavCoeffNorm));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(complexIm_norm_, wavCoeffNorm, 3));
     }
     catch (...)
     {
@@ -283,11 +283,26 @@ divideWavCoeffByNorm(hoNDArray<T>& wavCo
 
         if ( processApproxCoeff )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver4thDimension(wav_coeff_norm_approx_, wavCoeff, wavCoeff));
+            size_t num = wavCoeff.get_number_of_elements() / (RO*E1*W*CHA);
+
+#pragma omp parallel default(none) private(ii) shared(RO, E1, num, wavCoeffNorm, wavCoeff, W, CHA) if ( num > 1 )
+            {
+
+#pragma omp for
+                for (ii = 0; ii<(long long)num; ii++)
+                {
+                    hoNDArray<T> wavCoeffNormCurr(RO, E1, W, wav_coeff_norm_approx_.begin() + ii*RO*E1*W);
+
+                    for (size_t cha = 0; cha<CHA; cha++)
+                    {
+                        hoNDArray<T> wavCoeffCurr(RO, E1, W, wavCoeff.begin() + ii*RO*E1*W*CHA + cha*RO*E1*W);
+                        Gadgetron::multiply(wavCoeffNormCurr, wavCoeffCurr, wavCoeffCurr);
+                    }
+                }
+            }
         }
         else
         {
-            // GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver4thDimensionExcept(wav_coeff_norm_approx_, wavCoeff, 0, wavCoeff, true));
             size_t num = wavCoeff.get_number_of_elements()/(RO*E1*W*CHA);
 
             #pragma omp parallel default(none) private(ii) shared(RO, E1, num, wavCoeffNorm, wavCoeff, W, CHA) if ( num > 1 )
@@ -373,7 +388,22 @@ shrinkWavCoeff(hoNDArray<T>& wavCoeff, c
         }
 
         // phase does not change
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver4thDimension(res_after_apply_kernel_, wavCoeff, complexIm_));
+#pragma omp parallel default(none) private(ii) shared(RO, E1, num, wavCoeff, W, CHA) if ( num > 1 )
+        {
+#pragma omp for
+            for (ii = 0; ii<num; ii++)
+            {
+                hoNDArray<T> MagInvCurr(RO, E1, W, res_after_apply_kernel_.begin() + ii*RO*E1*W);
+
+                for (size_t cha = 0; cha<CHA; cha++)
+                {
+                    hoNDArray<T> wavCoeffCurr(RO, E1, W, wavCoeff.begin() + ii*RO*E1*W*CHA + cha*RO*E1*W);
+                    hoNDArray<T> resCurr(RO, E1, W, complexIm_.begin() + ii*RO*E1*W*CHA + cha*RO*E1*W);
+
+                    Gadgetron::multiply(MagInvCurr, wavCoeffCurr, resCurr);
+                }
+            }
+        }
 
         // shrink the magnitude
         if ( mask.dimensions_equal(&wavCoeffNorm) )
@@ -439,13 +469,30 @@ shrinkWavCoeff(hoNDArray<T>& wavCoeff, c
             }
         }
 
+        size_t W_Start = W;
         if ( processApproxCoeff )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver4thDimension(wav_coeff_norm_approx_, complexIm_, wavCoeff));
+            num = wavCoeff.get_number_of_elements() / (RO*E1*W*CHA);
+
+#pragma omp parallel default(none) private(ii) shared(RO, E1, num, wavCoeff, W, CHA) if ( num > 1 )
+            {
+#pragma omp for
+                for (ii = 0; ii<num; ii++)
+                {
+                    hoNDArray<T> MagCurr(RO, E1, W, wav_coeff_norm_approx_.begin() + ii*RO*E1*W);
+
+                    for (size_t cha = 0; cha<CHA; cha++)
+                    {
+                        hoNDArray<T> phaseCurr(RO, E1, W, complexIm_.begin() + ii*RO*E1*W*CHA + cha*RO*E1*W);
+                        hoNDArray<T> wavCoeffCurr(RO, E1, W, wavCoeff.begin() + ii*RO*E1*W*CHA + cha*RO*E1*W);
+
+                        Gadgetron::multiply(MagCurr, phaseCurr, wavCoeffCurr);
+                    }
+                }
+            }
         }
         else
         {
-            // GADGET_CHECK_RETURN_FALSE(Gadgetron::multiplyOver4thDimensionExcept(wav_coeff_norm_approx_, complexIm_, 0, wavCoeff, false));
             num = wavCoeff.get_number_of_elements()/(RO*E1*W*CHA);
 
             #pragma omp parallel default(none) private(ii) shared(RO, E1, num, wavCoeff, W, CHA) if ( num > 1 )
@@ -588,7 +635,7 @@ gradTask(const hoNDArray<T>& x, hoNDArra
         {
             // apply coil sensivity
             //gt_timer2_.start("10");
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(complexIm_wav_, *coil_senMap_, kspace_wav_));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(*coil_senMap_, complexIm_wav_, kspace_wav_));
             //gt_timer2_.stop();
 
             // go to kspace
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconUtil.cpp
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconUtil.cpp
@@ -23,1892 +23,524 @@ namespace Gadgetron {
     // templated functions
     // ----------------------------------------------------------------------------------------
 
-    template<typename T> 
-    bool sumOverLastDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
+    template <typename T> 
+    bool cropUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const std::vector<size_t>& startND, std::vector<size_t>& size)
     {
-        try
+        GADGET_CHECK_RETURN_FALSE( startND.size() == size.size() );
+        GADGET_CHECK_RETURN_FALSE( startND.size() <= 11 );
+
+        r.create(&size);
+        if ( r.get_number_of_elements() == x.get_number_of_elements() )
         {
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
-            size_t NDim = dim->size();
+            r = x;
+            return true;
+        }
 
-            std::vector<size_t> dimR(NDim-1);
+        std::vector<size_t> start(11, 0);
+        std::vector<size_t> end(11, 0);
 
-            size_t d;
-            for ( d=0; d<NDim-1; d++ )
-            {
-                dimR[d] = (*dim)[d];
-            }
+        size_t ii;
+        for ( ii=0; ii<startND.size(); ii++ )
+        {
+            start[ii] = startND[ii];
+            end[ii] = start[ii] + size[ii] - 1;
+            GADGET_CHECK_RETURN_FALSE(end[ii] < x.get_size(ii));
+        }
 
-            if ( !r.dimensions_equal(&dimR) )
-            {
-                r.create(&dimR);
-            }
+        // [Ro E1 Cha Slice E2 Con Phase Rep Set Seg Ave]
+        size_t e1, cha, n, s, con, phs, rep, set, seg, ave;
 
-            // Gadgetron::clear(&r);
+        std::vector<size_t> srcInd(11), dstInd(11);
+
+        for ( ave=start[10]; ave<=end[10]; ave++ )
+        {
+            srcInd[10] = ave; dstInd[10] = ave-start[10];
 
-            if ( x.get_size(NDim-1) <= 1 )
+            for ( seg=start[9]; seg<=end[9]; seg++ )
             {
-                memcpy(r.begin(), x.begin(), x.get_number_of_bytes());
-                return true;
-            }
+                srcInd[9] = seg; dstInd[9] = seg-start[9];
 
-            size_t lastDim = x.get_size(NDim-1);
-            size_t NR = r.get_number_of_elements();
-            T* pA = const_cast<T*>(x.begin());
-            T* pR = r.begin();
+                for ( set=start[8]; set<=end[8]; set++ )
+                {
+                    srcInd[8] = set; dstInd[8] = set-start[8];
 
-            memcpy(pR, pA, sizeof(T)*NR);
+                    for ( rep=start[7]; rep<=end[7]; rep++ )
+                    {
+                        srcInd[7] = rep; dstInd[7] = rep-start[7];
 
-            // sum over the last dim
-            hoNDArray<T> tmp;
-            for ( d=1; d<lastDim; d++ )
-            {
-                tmp.create(&dimR, pA+d*NR);
-                add(tmp, r, r);
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in sumOverLastDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
-            return false;
-        }
-        return true;
-    }
+                        for ( phs=start[6]; phs<=end[6]; phs++ )
+                        {
+                            srcInd[6] = phs; dstInd[6] = phs-start[6];
 
-    template<typename T> 
-    bool sumOverSecondLastDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
-            size_t NDim = dim->size();
+                            for ( con=start[5]; con<=end[5]; con++ )
+                            {
+                                srcInd[5] = con; dstInd[5] = con-start[5];
 
-            if ( NDim < 2 ) return true;
+                                for ( s=start[4]; s<=end[4]; s++ )
+                                {
+                                    srcInd[4] = s; dstInd[4] = s-start[4];
 
-            std::vector<size_t> dimR(NDim-1);
-            std::vector<size_t> dimRInternal(NDim-2);
+                                    for ( n=start[3]; n<=end[3]; n++ )
+                                    {
+                                        srcInd[3] = n; dstInd[3] = n-start[3];
 
-            size_t d;
-            for ( d=0; d<NDim-2; d++ )
-            {
-                dimR[d] = (*dim)[d];
-                dimRInternal[d] = (*dim)[d];
-            }
-            dimR[NDim-2] = (*dim)[NDim-1];
+                                        for ( cha=start[2]; cha<=end[2]; cha++ )
+                                        {
+                                            srcInd[2] = cha; dstInd[2] = cha-start[2];
 
-            if ( !r.dimensions_equal(&dimR) )
-            {
-                r.create(&dimR);
-            }
+                                            for ( e1=start[1]; e1<=end[1]; e1++ )
+                                            {
+                                                srcInd[1] = e1; dstInd[1] = e1-start[1];
 
-            if ( x.get_size(NDim-2) <= 1 )
-            {
-                memcpy(r.begin(), x.begin(), x.get_number_of_bytes());
-                return true;
-            }
+                                                srcInd[0] = start[0];
+                                                dstInd[0] = 0;
 
-            size_t lastDim = x.get_size(NDim-1);
-            size_t secondLastDim = x.get_size(NDim-2);
-            size_t NS = x.get_number_of_elements()/lastDim;
-            size_t NR = r.get_number_of_elements()/lastDim;
-            T* pA = const_cast<T*>(x.begin());
-            T* pR = r.begin();
+                                                size_t offsetSrc = x.calculate_offset(srcInd);
+                                                size_t offsetDst = r.calculate_offset(dstInd);
 
-            int l;
-            #pragma omp parallel default(none) private(l) shared(lastDim, secondLastDim, NS, NR, pA, pR, dimRInternal)
-            {
-                hoNDArray<T> tmp, tmp2;
+                                                memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, sizeof(T)*(end[0]-start[0]+1));
 
-                #pragma omp for
-                for ( l=0; l<(int)lastDim; l++ )
-                {
-                    memcpy(pR+l*NR, pA+l*NS, sizeof(T)*NR);
-                    tmp.create(&dimRInternal, pR+l*NR);
-                    for ( size_t s=1; s<secondLastDim; s++ )
-                    {
-                        tmp2.create(&dimRInternal, pA+l*NS+s*NR);
-                        add(tmp, tmp2, tmp);
+                                                /*for ( ro=start[0]; ro<=end[0]; ro++ )
+                                                {
+                                                    srcInd[0] = ro;
+                                                    dstInd[0] = ro-start[0];
+
+                                                    int offsetSrc = x.calculate_offset(srcInd);
+                                                    int offsetDst = r.calculate_offset(dstInd);
+
+                                                    r(offsetDst) = x(offsetSrc);
+                                                }*/
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
                     }
                 }
             }
         }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in sumOverSecondLastDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
-            return false;
-        }
+
         return true;
     }
 
-    // e.g. x is 3D and y is 4D array, r(:,:,:,n) = y(:,:,:,n) .* x
-    template<typename T> 
-    bool multiplyOverLastDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r)
+    template <typename T> 
+    bool setSubArrayUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const std::vector<size_t>& startND, std::vector<size_t>& size)
     {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y.get_dimensions();
+        GADGET_CHECK_RETURN_FALSE( startND.size() == size.size() );
+        GADGET_CHECK_RETURN_FALSE( startND.size() <= 11 );
 
-            size_t NDim = dimY->size();
+        if ( r.get_number_of_elements() == x.get_number_of_elements() )
+        {
+            r = x;
+            return true;
+        }
 
-            GADGET_CHECK_RETURN_FALSE(dimX->size()==NDim-1);
+        std::vector<size_t> start(11, 0);
+        std::vector<size_t> end(11, 0);
 
-            if ( !r.dimensions_equal(dimY.get()) )
-            {
-                r.create(dimY);
-            }
+        size_t ii;
+        for ( ii=0; ii<startND.size(); ii++ )
+        {
+            start[ii] = startND[ii];
+            end[ii] = start[ii] + size[ii] - 1;
+            GADGET_CHECK_RETURN_FALSE(end[ii] < r.get_size(ii));
+        }
 
-            if ( y.get_size(NDim-1) <= 1 )
-            {
-                multiply(x, y, r);
-                return true;
-            }
+        // [Ro E1 Cha Slice E2 Con Phase Rep Set Seg Ave]
+        size_t e1, cha, n, s, con, phs, rep, set, seg, ave;
 
-            size_t lastDim = y.get_size(NDim-1);
-            size_t N = x.get_number_of_elements();
-            const T* pX = x.begin();
-            const T* pY = y.begin();
-            T* pR = r.begin();
+        std::vector<size_t> srcInd(11), dstInd(11);
 
-            int d;
+        for ( ave=start[10]; ave<=end[10]; ave++ )
+        {
+            dstInd[10] = ave; srcInd[10] = ave-start[10];
 
-            #pragma omp parallel default(none) private(d) shared(x, dimX, lastDim, N, pY, pR)
+            for ( seg=start[9]; seg<=end[9]; seg++ )
             {
-                hoNDArray<T> tmpY, tmpR;
+                dstInd[9] = seg; srcInd[9] = seg-start[9];
 
-                #pragma omp for
-                for ( d=0; d<(int)lastDim; d++ )
+                for ( set=start[8]; set<=end[8]; set++ )
                 {
-                    tmpY.create(dimX.get(), const_cast<T*>(pY+d*N));
-                    tmpR.create(dimX.get(), pR+d*N);
-                    multiply(x, tmpY, tmpR);
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in multiplyOverLastDimension(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r) ... ");
-            return false;
-        }
-        return true;
-    }
+                    dstInd[8] = set; srcInd[8] = set-start[8];
 
-    // e.g. x is 3D and y is 4D array, r(:,:,:,n) = y(:,:,:,n) ./ x
-    template<typename T> 
-    bool divideOverLastDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y.get_dimensions();
+                    for ( rep=start[7]; rep<=end[7]; rep++ )
+                    {
+                        dstInd[7] = rep; srcInd[7] = rep-start[7];
 
-            size_t NDim = dimY->size();
+                        for ( phs=start[6]; phs<=end[6]; phs++ )
+                        {
+                            dstInd[6] = phs; srcInd[6] = phs-start[6];
 
-            GADGET_CHECK_RETURN_FALSE(dimX->size()==NDim-1);
+                            for ( con=start[5]; con<=end[5]; con++ )
+                            {
+                                dstInd[5] = con; srcInd[5] = con-start[5];
 
-            if ( !r.dimensions_equal(dimY.get()) )
-            {
-                r.create(dimY);
-            }
+                                for ( s=start[4]; s<=end[4]; s++ )
+                                {
+                                    dstInd[4] = s; srcInd[4] = s-start[4];
 
-            if ( y.get_size(NDim-1) <= 1 )
-            {
-                divide(y, x, r);
-                return true;
-            }
+                                    for ( n=start[3]; n<=end[3]; n++ )
+                                    {
+                                        dstInd[3] = n; srcInd[3] = n-start[3];
 
-            size_t lastDim = y.get_size(NDim-1);
-            size_t N = x.get_number_of_elements();
-            T* pY = const_cast<T*>(y.begin());
-            T* pR = r.begin();
+                                        for ( cha=start[2]; cha<=end[2]; cha++ )
+                                        {
+                                            dstInd[2] = cha; srcInd[2] = cha-start[2];
 
-            int d;
+                                            for ( e1=start[1]; e1<=end[1]; e1++ )
+                                            {
+                                                dstInd[1] = e1; srcInd[1] = e1-start[1];
 
-            #pragma omp parallel default(none) private(d) shared(x, dimX, lastDim, N, pY, pR)
-            {
-                hoNDArray<T> tmpY, tmpR;
+                                                dstInd[0] = start[0];
+                                                srcInd[0] = 0;
 
-                #pragma omp for
-                for ( d=0; d<(int)lastDim; d++ )
-                {
-                    tmpY.create(dimX, pY+d*N);
-                    tmpR.create(dimX, pR+d*N);
-                    divide(tmpY, x, tmpR);
+                                                size_t offsetSrc = x.calculate_offset(srcInd);
+                                                size_t offsetDst = r.calculate_offset(dstInd);
+
+                                                memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, sizeof(T)*(end[0]-start[0]+1));
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
                 }
             }
         }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in divideOverLastDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r) ... ");
-            return false;
-        }
+
         return true;
     }
 
     template<typename T> 
-    bool sumOver1stDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
+    bool extractSampledLinesUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const hoNDArray<float>& timeStamp, double acceFactorE1, double acceFactorE2)
     {
         try
         {
-            size_t RO = x.get_size(0);
-            size_t num = x.get_number_of_elements()/(RO);
+            std::vector<size_t> dim;
+            x.get_dimensions(dim);
 
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
+            size_t RO = x.get_size(0);
+            size_t E1 = x.get_size(1);
+            size_t CHA = x.get_size(2);
+            size_t SLC = x.get_size(3);
+            size_t E2 = x.get_size(4);
+            size_t CON = x.get_size(5);
+            size_t PHS = x.get_size(6);
+            size_t REP = x.get_size(7);
+            size_t SET = x.get_size(8);
+            size_t SEG = x.get_size(9);
+            size_t AVE = x.get_size(10);
 
-            std::vector<size_t> dimAve(*dim);
-            dimAve[0] = 1;
-            r.create(&dimAve);
+            size_t Num = AVE*SEG*SET*REP*PHS*SLC;
 
-            const T* pX = x.begin();
-            T* pR = r.begin();
+            std::vector<size_t> dimRes(dim);
 
-            int n;
-            #pragma omp parallel for default(none) private(n) shared(RO, num, pX, pR)
-            for ( n=0; n<(int)num; n++ )
+            if ( acceFactorE1>1 && E1>1 )
             {
-                T xsum = pX[n*RO];
-                for (size_t ro=1; ro<RO; ro++ )
-                {
-                    xsum += pX[n*RO+ro];
-                }
-
-                pR[n] = xsum;
+                dimRes[1] = (size_t)(E1/acceFactorE1) + 1;
             }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in sumOver1stDimension(...) ... ");
-            return false;
-        }
-
-        return true;
-    }
 
-    template<typename T> 
-    bool sumOver2ndDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            size_t NDim = x.get_number_of_dimensions();
+            size_t dstE1 = dimRes[1];
 
-            if ( NDim < 2 )
+            if ( acceFactorE2>1 && E2>1 )
             {
-                r = x;
-                return true;
+                dimRes[4] = (size_t)(E2/acceFactorE2) + 1;
             }
 
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-
-            size_t num = x.get_number_of_elements()/(RO*E1);
-
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
-
-            std::vector<size_t> dimAve(*dim);
-            dimAve[1] = 1;
-            r.create(&dimAve);
-
-            int n;
-            #pragma omp parallel for default(none) private(n) shared(RO, E1, num, x, r)
-            for ( n=0; n<(int)num; n++ )
-            {
-                hoNDArray<T> xsum(RO, const_cast<T*>(r.begin()+n*RO));
-                memcpy(xsum.begin(), x.begin()+n*RO*E1, xsum.get_number_of_bytes());
-
-                for (size_t e1=1; e1<E1; e1++ )
-                {
-                    hoNDArray<T> x1D(RO, const_cast<T*>(x.begin()+n*RO*E1+e1*RO));
-                    Gadgetron::add(x1D, xsum, xsum);
-                }
-            }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in sumOver2ndDimension(...) ... ");
-            return false;
-        }
+            r.create(&dimRes);
+            Gadgetron::clear(r);
 
-        return true;
-    }
+            // [Ro E1 Cha Slice E2 Con Phase Rep Set Seg Ave]
 
-    template<typename T> 
-    bool sumOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            size_t NDim = x.get_number_of_dimensions();
+            size_t ROLen = sizeof(T)*RO;
+            hoNDArray<T> dummyArray(SLC, CON, PHS, REP, SET, SEG, AVE);
 
-            if ( NDim < 3 )
+            long long n;
+            #pragma omp parallel default(none) private(n) shared(Num, dummyArray, RO, E1, CHA, SLC, E2, CON, PHS, REP, SET, SEG, AVE, timeStamp, x, r, ROLen, dstE1)
             {
-                r = x;
-                return true;
-            }
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t CHA = x.get_size(2);
-
-            size_t num = x.get_number_of_elements()/(RO*E1*CHA);
-
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
-
-            std::vector<size_t> dimAve(*dim);
-            dimAve[2] = 1;
-            r.create(&dimAve);
 
-            int n;
-            #pragma omp parallel default(none) private(n) shared(RO, E1, CHA, num, x, r) if (num>1)
-            {
-                hoNDArray<T> xsum;
-                hoNDArray<T> x2D;
+                std::vector<size_t> indN;
+                std::vector<size_t> srcInd(11, 0), dstInd(11, 0);
+                size_t e1, cha, slc, e2, con, rep, phs, set, seg, ave;
 
                 #pragma omp for
-                for ( n=0; n<(int)num; n++ )
+                for ( n=0; n<(long long)Num; n++ )
                 {
-                    xsum.create(RO, E1, const_cast<T*>(r.begin()+n*RO*E1));
-                    memcpy(xsum.begin(), x.begin()+n*RO*E1*CHA, xsum.get_number_of_bytes());
+                    indN = dummyArray.calculate_index(n);
 
-                    for (size_t cha=1; cha<CHA; cha++ )
-                    {
-                        x2D.create(RO, E1, const_cast<T*>(x.begin()+n*RO*E1*CHA+cha*RO*E1));
-                        Gadgetron::add(x2D, xsum, xsum);
-                    }
-                }
-            }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in sumOver3rdDimension(...) ... ");
-            return false;
-        }
+                    ave = indN[6];
+                    seg = indN[5];
+                    set = indN[4];
+                    rep = indN[3];
+                    phs = indN[2];
+                    con = indN[1];
+                    slc = indN[0];
 
-        return true;
-    }
+                    srcInd[10] = ave; dstInd[10] = ave;
+                    srcInd[9] = seg; dstInd[9] = seg;
+                    srcInd[8] = set; dstInd[8] = set;
+                    srcInd[7] = rep; dstInd[7] = rep;
+                    srcInd[6] = phs; dstInd[6] = phs;
+                    srcInd[5] = con; dstInd[5] = con;
+                    srcInd[4] = slc; dstInd[4] = slc;
 
-    template<typename T> bool sumOver4thDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            size_t NDim = x.get_number_of_dimensions();
+                    // ------------------
+                    size_t indE2(0);
+                    size_t prevE2(0);
+                    for ( e2=0; e2<E2; e2++ )
+                    {
+                        srcInd[3] = e2; dstInd[3] = indE2;
 
-            if ( NDim < 4 )
-            {
-                r = x;
-                return true;
-            }
+                        size_t indE1(0);
+                        for ( e1=0; e1<E1; e1++ )
+                        {
+                            srcInd[1] = e1; 
 
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t CHA = x.get_size(2);
-            size_t N = x.get_size(3);
+                            srcInd[2] = 0;
+                            if ( timeStamp(srcInd) > 0 )
+                            {
+                                dstInd[1] = indE1;
+                                indE1++;
 
-            size_t num = x.get_number_of_elements()/(RO*E1*CHA*N);
+                                if ( e2 != prevE2 )
+                                {
+                                    prevE2 = e2;
+                                    indE2++;
+                                }
 
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
+                                // ------------------
+                                srcInd[2] = 0; dstInd[2] = 0;
+                                size_t offsetSrc = x.calculate_offset(srcInd);
+                                size_t offsetDst = r.calculate_offset(dstInd);
 
-            std::vector<size_t> dimAve(*dim);
-            dimAve[3] = 1;
-            r.create(&dimAve);
-
-            int n;
-            #pragma omp parallel for default(none) private(n) shared(RO, E1, CHA, N, num, x, r)
-            for ( n=0; n<(int)num; n++ )
-            {
-                hoNDArray<T> xsum(RO, E1, CHA, const_cast<T*>(r.begin()+n*RO*E1*CHA));
-                memcpy(xsum.begin(), x.begin()+n*RO*E1*CHA*N, xsum.get_number_of_bytes());
+                                for ( cha=0; cha<CHA; cha++ )
+                                {
+                                    memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, ROLen);
 
-                for (size_t nn=1; nn<N; nn++ )
-                {
-                    hoNDArray<T> x3D(RO, E1, CHA, const_cast<T*>(x.begin()+n*RO*E1*CHA*N+nn*RO*E1*CHA));
-                    Gadgetron::add(x3D, xsum, xsum);
+                                    offsetSrc += RO*E1;
+                                    offsetDst += RO*dstE1;
+                                }
+                                // ------------------
+                            }
+                        }
+                        // ------------------
+                    }
                 }
             }
         }
         catch(...)
         {
-            GERROR_STREAM("Errors in sumOver4thDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
+            GERROR_STREAM("Errors in extractSampledLinesUpTo11DArray(...) ... ");
             return false;
         }
 
         return true;
     }
 
-    template<typename T> bool sumOver5thDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
+    template<typename T> 
+    bool fillSampledLinesUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const hoNDArray<float>& timeStamp)
     {
         try
         {
-            size_t NDim = x.get_number_of_dimensions();
-
-            if ( NDim < 5 )
-            {
-                r = x;
-                return true;
-            }
-
             size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
+            size_t E1 = timeStamp.get_size(1);
             size_t CHA = x.get_size(2);
-            size_t N = x.get_size(3);
-            size_t S = x.get_size(4);
-
-            size_t num = x.get_number_of_elements()/(RO*E1*CHA*N*S);
-
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
-
-            std::vector<size_t> dimAve(*dim);
-            dimAve[4] = 1;
-            r.create(&dimAve);
-
-            int n;
-            #pragma omp parallel for default(none) private(n) shared(RO, E1, CHA, N, S, num, x, r) if (num > 4)
-            for ( n=0; n<(int)num; n++ )
-            {
-                hoNDArray<T> xsum(RO, E1, CHA, N, const_cast<T*>(r.begin()+n*RO*E1*CHA*N));
-                memcpy(xsum.begin(), x.begin()+n*RO*E1*CHA*N*S, xsum.get_number_of_bytes());
-
-                for (size_t s=1; s<S; s++ )
-                {
-                    hoNDArray<T> x4D(RO, E1, CHA, N, const_cast<T*>(x.begin()+n*RO*E1*CHA*N*S+s*RO*E1*CHA*N));
-                    Gadgetron::add(x4D, xsum, xsum);
-                }
-            }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in sumOver5thDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
-            return false;
-        }
-
-        return true;
-    }
+            size_t SLC = timeStamp.get_size(3);
+            size_t E2 = timeStamp.get_size(4);
+            size_t CON = timeStamp.get_size(5);
+            size_t PHS = timeStamp.get_size(6);
+            size_t REP = timeStamp.get_size(7);
+            size_t SET = timeStamp.get_size(8);
+            size_t SEG = timeStamp.get_size(9);
+            size_t AVE = timeStamp.get_size(10);
 
-    // e.g. x is 3D and y is 4D array, r(:,:,n,:) = y(:,:,n,:) .* x3D
-    template<typename T> 
-    bool multiplyOver3rdDimension(const hoNDArray<T>& x3D, const hoNDArray<T>& y4D, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x3D.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y4D.get_dimensions();
+            size_t srcE1 = x.get_size(1);
 
-            size_t NDim = dimY->size();
+            size_t Num = AVE*SEG*SET*REP*PHS*SLC;
 
-            GADGET_CHECK_RETURN_FALSE(dimX->size()>=3);
-            GADGET_CHECK_RETURN_FALSE(NDim>=4);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[0]==(*dimY)[0]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[1]==(*dimY)[1]);
+            std::vector<size_t> dimRes;
+            timeStamp.get_dimensions(dimRes);
 
-            if ( !r.dimensions_equal(dimY.get()) )
-            {
-                r.create(dimY);
-            }
+            dimRes[0] = RO;
+            dimRes[2] = CHA;
+            r.create(&dimRes);
+            Gadgetron::clear(r);
 
-            long long t, N2D = (long long)x3D.get_size(0)*x3D.get_size(1);
-            long long sz = (long long)y4D.get_size(2);
-            long long st = (long long)y4D.get_number_of_elements()/(N2D*sz);
+            size_t ROLen = sizeof(T)*RO;
+            hoNDArray<T> dummyArray(SLC, CON, PHS, REP, SET, SEG, AVE);
 
-            if ( sz == 1 )
+            long long n;
+            #pragma omp parallel default(none) private(n) shared(Num, dummyArray, RO, E1, CHA, SLC, E2, CON, PHS, REP, SET, SEG, AVE, timeStamp, x, r, ROLen, srcE1)
             {
-                multiply(x3D, y4D, r);
-                return true;
-            }
-
-            const T* pX = x3D.begin();
-            const T* pY = y4D.begin();
-            T* pR = r.begin();
-
-            std::vector<size_t> dim2D(2);
-            dim2D[0] = (*dimY)[0];
-            dim2D[1] = (*dimY)[1];
 
-            #pragma omp parallel for default(none) private(t) shared(N2D, sz, st, dim2D, pX, pY, pR)
-            for ( t=0; t<st; t++ )
-            {
-                hoNDArray<T> tmpX, tmpY, tmpR;
-                tmpX.create(&dim2D, const_cast<T*>(pX+t*N2D));
+                std::vector<size_t> indN;
+                std::vector<size_t> srcInd(11, 0), dstInd(11, 0);
+                size_t e1, cha, slc, e2, con, rep, phs, set, seg, ave;
 
-                for ( long long z=0; z<sz; z++ )
+                #pragma omp for
+                for ( n=0; n<(long long)Num; n++ )
                 {
-                    tmpY.create(&dim2D, const_cast<T*>(pY+t*N2D*sz+z*N2D));
-                    tmpR.create(&dim2D, pR+t*N2D*sz+z*N2D);
-                    multiply(tmpX, tmpY, tmpR);
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in multiplyOver3rdDimension(const hoNDArray<float>& x3D, const hoNDArray<float>& y4D, hoNDArray<float>& r) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> 
-    bool multiplyOver4thDimension(const hoNDArray<T>& x4D, const hoNDArray<T>& y5D, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x4D.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y5D.get_dimensions();
-
-            size_t NDim = dimY->size();
-
-            GADGET_CHECK_RETURN_FALSE(dimX->size()>=4);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[0]==(*dimY)[0]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[1]==(*dimY)[1]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[2]==(*dimY)[2]);
-
-            if ( !r.dimensions_equal(dimY.get()) )
-            {
-                r.create(dimY);
-            }
-
-            size_t RO = (*dimX)[0];
-            size_t E1 = (*dimX)[1];
-            size_t CHA = (*dimX)[2];
-
-            long long t, N3D = (long long)RO*E1*CHA;
+                    indN = dummyArray.calculate_index(n);
 
-            size_t N = (*dimY)[3];
-            size_t num = x4D.get_number_of_elements()/(RO*E1*CHA);
+                    ave = indN[6];
+                    seg = indN[5];
+                    set = indN[4];
+                    rep = indN[3];
+                    phs = indN[2];
+                    con = indN[1];
+                    slc = indN[0];
 
-            const T* pX = x4D.begin();
-            const T* pY = y5D.begin();
-            T* pR = r.begin();
+                    srcInd[10] = ave; dstInd[10] = ave;
+                    srcInd[9] = seg; dstInd[9] = seg;
+                    srcInd[8] = set; dstInd[8] = set;
+                    srcInd[7] = rep; dstInd[7] = rep;
+                    srcInd[6] = phs; dstInd[6] = phs;
+                    srcInd[5] = con; dstInd[5] = con;
+                    srcInd[4] = slc; dstInd[4] = slc;
 
-            std::vector<size_t> dim3D(3);
-            dim3D[0] = RO;
-            dim3D[1] = E1;
-            dim3D[2] = CHA;
+                    // ------------------
+                    size_t indE2(0);
+                    size_t prevE2(0);
+                    for ( e2=0; e2<E2; e2++ )
+                    {
+                        srcInd[3] = indE2; dstInd[3] = e2;
 
-            #pragma omp parallel for default(none) private(t) shared(N3D, N, dim3D, pX, pY, pR, num)
-            for ( t=0; t<(int)num; t++ )
-            {
-                hoNDArray<T> tmpX, tmpY, tmpR;
-                tmpX.create(&dim3D, const_cast<T*>(pX+t*N3D));
+                        size_t indE1(0);
+                        for ( e1=0; e1<E1; e1++ )
+                        {
+                            dstInd[1] = e1; 
 
-                for ( int n=0; n<N; n++ )
-                {
-                    tmpY.create(&dim3D, const_cast<T*>(pY+t*N3D*N+n*N3D));
-                    tmpR.create(&dim3D, pR+t*N3D*N+n*N3D);
-                    multiply(tmpX, tmpY, tmpR);
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in multiplyOver4thDimension(const hoNDArray<float>& x4D, const hoNDArray<float>& y5D, hoNDArray<float>& r) ... ");
-            return false;
-        }
-        return true;
-    }
+                            dstInd[2] = 0;
+                            if ( timeStamp(dstInd) > 0 )
+                            {
+                                srcInd[1] = indE1;
+                                indE1++;
 
-    template<typename T> 
-    bool multiplyOver4thDimensionExcept(const hoNDArray<T>& x4D, const hoNDArray<T>& y5D, size_t n, hoNDArray<T>& r, bool copyY2R)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x4D.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y5D.get_dimensions();
-
-            size_t NDim = dimY->size();
-
-            GADGET_CHECK_RETURN_FALSE(dimX->size()>=4);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[0]==(*dimY)[0]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[1]==(*dimY)[1]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[2]==(*dimY)[2]);
-
-            const T* pX = x4D.begin();
-            const T* pY = y5D.begin();
-            T* pR = r.begin();
-
-            if ( (pR!=pY) && (!r.dimensions_equal(dimY.get())) )
-            {
-                r.create(dimY);
-                pR = r.begin();
-            }
-
-            size_t RO = (*dimX)[0];
-            size_t E1 = (*dimX)[1];
-            size_t CHA = (*dimX)[2];
-
-            long long t, N3D = (long long)RO*E1*CHA;
-
-            long long N = (long long)(*dimY)[3];
-            long long num = (long long)x4D.get_number_of_elements()/(RO*E1*CHA);
-
-            std::vector<size_t> dim3D(3);
-            dim3D[0] = RO;
-            dim3D[1] = E1;
-            dim3D[2] = CHA;
-
-            #pragma omp parallel for default(none) private(t) shared(N3D, N, dim3D, pX, pY, pR, num, n, copyY2R)
-            for ( t=0; t<num; t++ )
-            {
-                hoNDArray<T> tmpX, tmpY, tmpR;
-                tmpX.create(&dim3D, const_cast<T*>(pX+t*N3D));
-
-                for ( long long z=0; z<N; z++ )
-                {
-                    if ( z != n )
-                    {
-                        tmpY.create(&dim3D, const_cast<T*>(pY+t*N3D*N+z*N3D));
-                        tmpR.create(&dim3D, pR+t*N3D*N+z*N3D);
-                        multiply(tmpX, tmpY, tmpR);
-                    }
-                    else
-                    {
-                        if ( pR != pY )
-                        {
-                            if ( copyY2R )
-                            {
-                                memcpy(pR+t*N3D*N+z*N3D, const_cast<T*>(pY+t*N3D*N+z*N3D), sizeof(T)*N3D);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in multiplyOver4thDimensionExcept(const hoNDArray<float>& x4D, const hoNDArray<float>& y5D, size_t n, hoNDArray<float>& r, bool copyY2R) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T>
-    bool multiplyOver5thDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y.get_dimensions();
-
-            size_t NDim = dimY->size();
-
-            GADGET_CHECK_RETURN_FALSE(dimX->size()>=5);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[0]==(*dimY)[0]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[1]==(*dimY)[1]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[2]==(*dimY)[2]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[3]==(*dimY)[3]);
-
-            if ( !r.dimensions_equal(dimY.get()) )
-            {
-                r.create(dimY);
-            }
-
-            size_t RO = (*dimX)[0];
-            size_t E1 = (*dimX)[1];
-            size_t E2 = (*dimX)[2];
-            size_t CHA = (*dimX)[3];
-
-            int t;
-            size_t N4D = RO*E1*E2*CHA;
-
-            size_t N = (*dimY)[4];
-            size_t num = x.get_number_of_elements()/N4D;
-
-            const T* pX = x.begin();
-            const T* pY = y.begin();
-            T* pR = r.begin();
-
-            std::vector<size_t> dim4D(4);
-            dim4D[0] = RO;
-            dim4D[1] = E1;
-            dim4D[2] = E2;
-            dim4D[3] = CHA;
-
-            #pragma omp parallel for default(none) private(t) shared(N4D, N, dim4D, pX, pY, pR, num)
-            for ( t=0; t<(int)num; t++ )
-            {
-                hoNDArray<T> tmpX, tmpY, tmpR;
-                tmpX.create(&dim4D, const_cast<T*>(pX+t*N4D));
-
-                for ( int n=0; n<N; n++ )
-                {
-                    tmpY.create(&dim4D, const_cast<T*>(pY+t*N4D*N+n*N4D));
-                    tmpR.create(&dim4D, pR+t*N4D*N+n*N4D);
-                    multiply(tmpX, tmpY, tmpR);
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in multiplyOver5thDimension(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> 
-    bool multiplyOver5thDimensionExcept(const hoNDArray<T>& x, const hoNDArray<T>& y, size_t n, hoNDArray<T>& r, bool copyY2R)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-            boost::shared_ptr< std::vector<size_t> > dimY = y.get_dimensions();
-
-            size_t NDim = dimY->size();
-
-            GADGET_CHECK_RETURN_FALSE(dimX->size()>=5);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[0]==(*dimY)[0]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[1]==(*dimY)[1]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[2]==(*dimY)[2]);
-            GADGET_CHECK_RETURN_FALSE((*dimX)[3]==(*dimY)[3]);
-
-            const T* pX = x.begin();
-            const T* pY = y.begin();
-            T* pR = r.begin();
-
-            if ( (pR!=pY) && (!r.dimensions_equal(dimY.get())) )
-            {
-                r.create(dimY);
-                pR = r.begin();
-            }
-
-            size_t RO = (*dimX)[0];
-            size_t E1 = (*dimX)[1];
-            size_t E2 = (*dimX)[2];
-            size_t CHA = (*dimX)[3];
-
-            int t;
-            size_t N4D = RO*E1*E2*CHA;
-
-            size_t N = (*dimY)[4];
-            size_t num = x.get_number_of_elements()/N4D;
-
-            std::vector<size_t> dim4D(4);
-            dim4D[0] = RO;
-            dim4D[1] = E1;
-            dim4D[2] = E2;
-            dim4D[3] = CHA;
-
-            #pragma omp parallel for default(none) private(t) shared(N4D, dim4D, pX, pY, pR, num, n, N, copyY2R)
-            for ( t=0; t<(int)num; t++ )
-            {
-                hoNDArray<T> tmpX, tmpY, tmpR;
-                tmpX.create(&dim4D, const_cast<T*>(pX+t*N4D));
-
-                for ( int z=0; z<N; z++ )
-                {
-                    if ( z != n )
-                    {
-                        tmpY.create(&dim4D, const_cast<T*>(pY+t*N4D*N+z*N4D));
-                        tmpR.create(&dim4D, pR+t*N4D*N+z*N4D);
-                        multiply(tmpX, tmpY, tmpR);
-                    }
-                    else
-                    {
-                        if ( pR != pY )
-                        {
-                            if ( copyY2R )
-                            {
-                                memcpy(pR+t*N4D*N+z*N4D, const_cast<T*>(pY+t*N4D*N+z*N4D), sizeof(T)*N4D);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in multiplyOver5thDimensionExcept(const hoNDArray<T>& x, const hoNDArray<T>& y, size_t n, hoNDArray<T>& r, bool copyY2R) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template <typename T> 
-    bool multipleAdd(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r)
-    {
-        GADGET_DEBUG_CHECK_RETURN_FALSE(x.get_number_of_elements()<=y.get_number_of_elements());
-        if ( r.get_number_of_elements()!=y.get_number_of_elements())
-        {
-            r = y;
-        }
-
-        long long Nx = x.get_number_of_elements();
-        long long N = y.get_number_of_elements() / Nx;
-
-        const T* pX = x.begin();
-
-        long long n;
-        #pragma omp parallel for default(none) private(n) shared(pX, y, r, Nx, N)
-        for ( n=0; n<N; n++ )
-        {
-            const T* pY = y.begin()+n*Nx;
-            T* pR = r.begin() + n*Nx;
-
-            long long ii;
-            for ( ii=0; ii<Nx; ii++ )
-            {
-                pR[ii] = pX[ii] + pY[ii];
-            }
-        }
-
-        return true;
-    }
-
-    inline void multiplyCplx(size_t N, const  std::complex<float> * x, const  std::complex<float> * y,  std::complex<float> * r)
-    {
-        long long n;
-        #pragma omp parallel for default(none) private(n) shared(N, x, y, r) if (N>64*1024)
-        for (n = 0; n < (long long)N; n++)
-        {
-            const std::complex<float>& a1 = x[n];
-            const std::complex<float>& b1 = y[n];
-            const float a = a1.real();
-            const float b = a1.imag();
-            const float c = b1.real();
-            const float d = b1.imag();
-
-            reinterpret_cast<float(&)[2]>(r[n])[0] = a*c-b*d;
-            reinterpret_cast<float(&)[2]>(r[n])[1] = a*d+b*c;
-        }
-    }
-
-    inline void multiplyCplx(size_t N, const  std::complex<double> * x, const  std::complex<double> * y,  std::complex<double> * r)
-    {
-        long long n;
-        #pragma omp parallel for default(none) private(n) shared(N, x, y, r) if (N>64*1024)
-        for (n = 0; n < (long long)N; n++)
-        {
-            const std::complex<double>& a1 = x[n];
-            const std::complex<double>& b1 = y[n];
-            const double a = a1.real();
-            const double b = a1.imag();
-            const double c = b1.real();
-            const double d = b1.imag();
-
-            reinterpret_cast<double(&)[2]>(r[n])[0] = a*c-b*d;
-            reinterpret_cast<double(&)[2]>(r[n])[1] = a*d+b*c;
-        }
-    }
-
-    template <typename T> 
-    bool multipleMultiply(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r)
-    {
-        GADGET_DEBUG_CHECK_RETURN_FALSE(x.get_number_of_elements()<=y.get_number_of_elements());
-        if ( r.get_number_of_elements()!=y.get_number_of_elements())
-        {
-            r = y;
-        }
-
-        long long Nx = x.get_number_of_elements();
-        long long N = y.get_number_of_elements() / Nx;
-
-        const T* pX = x.begin();
-
-        long long n;
-
-        if ( typeid(T)==typeid(float) )
-        {
-            #pragma omp parallel for default(none) private(n) shared(pX, y, r, Nx, N)
-            for ( n=0; n<N; n++ )
-            {
-                const T* pY = y.begin()+n*Nx;
-                T* pR = r.begin() + n*Nx;
-
-                long long ii;
-                for ( ii=0; ii<Nx; ii++ )
-                {
-                    pR[ii] = pX[ii] * pY[ii];
-                }
-            }
-        }
-        else if ( typeid(T)==typeid(double) )
-        {
-            #pragma omp parallel for default(none) private(n) shared(pX, y, r, Nx, N)
-            for ( n=0; n<N; n++ )
-            {
-                const T* pY = y.begin()+n*Nx;
-                T* pR = r.begin() + n*Nx;
-
-                long long ii;
-                for ( ii=0; ii<Nx; ii++ )
-                {
-                    pR[ii] = pX[ii] * pY[ii];
-                }
-            }
-        }
-        else if ( typeid(T)==typeid( std::complex<float> ) )
-        {
-            #pragma omp parallel for default(none) private(n) shared(x, y, r, Nx, N)
-            for ( n=0; n<N; n++ )
-            {
-                multiplyCplx(x.get_number_of_elements(), (const std::complex<float>*)(x.begin()), (const std::complex<float>*)(y.begin()+n*Nx), (std::complex<float>*)(r.begin()+n*Nx));
-            }
-        }
-        else if ( typeid(T)==typeid( std::complex<double> ) )
-        {
-            #pragma omp parallel for default(none) private(n) shared(x, y, r, Nx, N)
-            for ( n=0; n<N; n++ )
-            {
-                multiplyCplx(x.get_number_of_elements(), (const std::complex<double>*)(x.begin()), (const std::complex<double>*)(y.begin()+n*Nx), (std::complex<double>*)(r.begin()+n*Nx));
-            }
-        }
-        else
-        {
-            GERROR_STREAM("multipleMultiply : unsupported type " << typeid(T).name());
-            return false;
-        }
-
-        return true;
-    }
-
-    template <typename T> 
-    bool cropUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const std::vector<size_t>& startND, std::vector<size_t>& size)
-    {
-        GADGET_CHECK_RETURN_FALSE( startND.size() == size.size() );
-        GADGET_CHECK_RETURN_FALSE( startND.size() <= 11 );
-
-        r.create(&size);
-        if ( r.get_number_of_elements() == x.get_number_of_elements() )
-        {
-            r = x;
-            return true;
-        }
-
-        std::vector<size_t> start(11, 0);
-        std::vector<size_t> end(11, 0);
-
-        size_t ii;
-        for ( ii=0; ii<startND.size(); ii++ )
-        {
-            start[ii] = startND[ii];
-            end[ii] = start[ii] + size[ii] - 1;
-            GADGET_CHECK_RETURN_FALSE(end[ii] < x.get_size(ii));
-        }
-
-        // [Ro E1 Cha Slice E2 Con Phase Rep Set Seg Ave]
-        size_t e1, cha, n, s, con, phs, rep, set, seg, ave;
-
-        std::vector<size_t> srcInd(11), dstInd(11);
-
-        for ( ave=start[10]; ave<=end[10]; ave++ )
-        {
-            srcInd[10] = ave; dstInd[10] = ave-start[10];
-
-            for ( seg=start[9]; seg<=end[9]; seg++ )
-            {
-                srcInd[9] = seg; dstInd[9] = seg-start[9];
-
-                for ( set=start[8]; set<=end[8]; set++ )
-                {
-                    srcInd[8] = set; dstInd[8] = set-start[8];
-
-                    for ( rep=start[7]; rep<=end[7]; rep++ )
-                    {
-                        srcInd[7] = rep; dstInd[7] = rep-start[7];
-
-                        for ( phs=start[6]; phs<=end[6]; phs++ )
-                        {
-                            srcInd[6] = phs; dstInd[6] = phs-start[6];
-
-                            for ( con=start[5]; con<=end[5]; con++ )
-                            {
-                                srcInd[5] = con; dstInd[5] = con-start[5];
-
-                                for ( s=start[4]; s<=end[4]; s++ )
-                                {
-                                    srcInd[4] = s; dstInd[4] = s-start[4];
-
-                                    for ( n=start[3]; n<=end[3]; n++ )
-                                    {
-                                        srcInd[3] = n; dstInd[3] = n-start[3];
-
-                                        for ( cha=start[2]; cha<=end[2]; cha++ )
-                                        {
-                                            srcInd[2] = cha; dstInd[2] = cha-start[2];
-
-                                            for ( e1=start[1]; e1<=end[1]; e1++ )
-                                            {
-                                                srcInd[1] = e1; dstInd[1] = e1-start[1];
-
-                                                srcInd[0] = start[0];
-                                                dstInd[0] = 0;
-
-                                                size_t offsetSrc = x.calculate_offset(srcInd);
-                                                size_t offsetDst = r.calculate_offset(dstInd);
-
-                                                memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, sizeof(T)*(end[0]-start[0]+1));
-
-                                                /*for ( ro=start[0]; ro<=end[0]; ro++ )
-                                                {
-                                                    srcInd[0] = ro;
-                                                    dstInd[0] = ro-start[0];
-
-                                                    int offsetSrc = x.calculate_offset(srcInd);
-                                                    int offsetDst = r.calculate_offset(dstInd);
-
-                                                    r(offsetDst) = x(offsetSrc);
-                                                }*/
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return true;
-    }
-
-    template <typename T> 
-    bool setSubArrayUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const std::vector<size_t>& startND, std::vector<size_t>& size)
-    {
-        GADGET_CHECK_RETURN_FALSE( startND.size() == size.size() );
-        GADGET_CHECK_RETURN_FALSE( startND.size() <= 11 );
-
-        if ( r.get_number_of_elements() == x.get_number_of_elements() )
-        {
-            r = x;
-            return true;
-        }
-
-        std::vector<size_t> start(11, 0);
-        std::vector<size_t> end(11, 0);
-
-        size_t ii;
-        for ( ii=0; ii<startND.size(); ii++ )
-        {
-            start[ii] = startND[ii];
-            end[ii] = start[ii] + size[ii] - 1;
-            GADGET_CHECK_RETURN_FALSE(end[ii] < r.get_size(ii));
-        }
-
-        // [Ro E1 Cha Slice E2 Con Phase Rep Set Seg Ave]
-        size_t e1, cha, n, s, con, phs, rep, set, seg, ave;
-
-        std::vector<size_t> srcInd(11), dstInd(11);
-
-        for ( ave=start[10]; ave<=end[10]; ave++ )
-        {
-            dstInd[10] = ave; srcInd[10] = ave-start[10];
-
-            for ( seg=start[9]; seg<=end[9]; seg++ )
-            {
-                dstInd[9] = seg; srcInd[9] = seg-start[9];
-
-                for ( set=start[8]; set<=end[8]; set++ )
-                {
-                    dstInd[8] = set; srcInd[8] = set-start[8];
-
-                    for ( rep=start[7]; rep<=end[7]; rep++ )
-                    {
-                        dstInd[7] = rep; srcInd[7] = rep-start[7];
-
-                        for ( phs=start[6]; phs<=end[6]; phs++ )
-                        {
-                            dstInd[6] = phs; srcInd[6] = phs-start[6];
-
-                            for ( con=start[5]; con<=end[5]; con++ )
-                            {
-                                dstInd[5] = con; srcInd[5] = con-start[5];
-
-                                for ( s=start[4]; s<=end[4]; s++ )
-                                {
-                                    dstInd[4] = s; srcInd[4] = s-start[4];
-
-                                    for ( n=start[3]; n<=end[3]; n++ )
-                                    {
-                                        dstInd[3] = n; srcInd[3] = n-start[3];
-
-                                        for ( cha=start[2]; cha<=end[2]; cha++ )
-                                        {
-                                            dstInd[2] = cha; srcInd[2] = cha-start[2];
-
-                                            for ( e1=start[1]; e1<=end[1]; e1++ )
-                                            {
-                                                dstInd[1] = e1; srcInd[1] = e1-start[1];
-
-                                                dstInd[0] = start[0];
-                                                srcInd[0] = 0;
-
-                                                size_t offsetSrc = x.calculate_offset(srcInd);
-                                                size_t offsetDst = r.calculate_offset(dstInd);
-
-                                                memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, sizeof(T)*(end[0]-start[0]+1));
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return true;
-    }
-
-    template<typename T> 
-    bool extractSampledLinesUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const hoNDArray<float>& timeStamp, double acceFactorE1, double acceFactorE2)
-    {
-        try
-        {
-            std::vector<size_t> dim;
-            x.get_dimensions(dim);
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t CHA = x.get_size(2);
-            size_t SLC = x.get_size(3);
-            size_t E2 = x.get_size(4);
-            size_t CON = x.get_size(5);
-            size_t PHS = x.get_size(6);
-            size_t REP = x.get_size(7);
-            size_t SET = x.get_size(8);
-            size_t SEG = x.get_size(9);
-            size_t AVE = x.get_size(10);
-
-            size_t Num = AVE*SEG*SET*REP*PHS*SLC;
-
-            std::vector<size_t> dimRes(dim);
-
-            if ( acceFactorE1>1 && E1>1 )
-            {
-                dimRes[1] = (size_t)(E1/acceFactorE1) + 1;
-            }
-
-            size_t dstE1 = dimRes[1];
-
-            if ( acceFactorE2>1 && E2>1 )
-            {
-                dimRes[4] = (size_t)(E2/acceFactorE2) + 1;
-            }
-
-            r.create(&dimRes);
-            Gadgetron::clear(r);
-
-            // [Ro E1 Cha Slice E2 Con Phase Rep Set Seg Ave]
-
-            size_t ROLen = sizeof(T)*RO;
-            hoNDArray<T> dummyArray(SLC, CON, PHS, REP, SET, SEG, AVE);
-
-            long long n;
-            #pragma omp parallel default(none) private(n) shared(Num, dummyArray, RO, E1, CHA, SLC, E2, CON, PHS, REP, SET, SEG, AVE, timeStamp, x, r, ROLen, dstE1)
-            {
-
-                std::vector<size_t> indN;
-                std::vector<size_t> srcInd(11, 0), dstInd(11, 0);
-                size_t e1, cha, slc, e2, con, rep, phs, set, seg, ave;
-
-                #pragma omp for
-                for ( n=0; n<(long long)Num; n++ )
-                {
-                    indN = dummyArray.calculate_index(n);
-
-                    ave = indN[6];
-                    seg = indN[5];
-                    set = indN[4];
-                    rep = indN[3];
-                    phs = indN[2];
-                    con = indN[1];
-                    slc = indN[0];
-
-                    srcInd[10] = ave; dstInd[10] = ave;
-                    srcInd[9] = seg; dstInd[9] = seg;
-                    srcInd[8] = set; dstInd[8] = set;
-                    srcInd[7] = rep; dstInd[7] = rep;
-                    srcInd[6] = phs; dstInd[6] = phs;
-                    srcInd[5] = con; dstInd[5] = con;
-                    srcInd[4] = slc; dstInd[4] = slc;
-
-                    // ------------------
-                    size_t indE2(0);
-                    size_t prevE2(0);
-                    for ( e2=0; e2<E2; e2++ )
-                    {
-                        srcInd[3] = e2; dstInd[3] = indE2;
-
-                        size_t indE1(0);
-                        for ( e1=0; e1<E1; e1++ )
-                        {
-                            srcInd[1] = e1; 
-
-                            srcInd[2] = 0;
-                            if ( timeStamp(srcInd) > 0 )
-                            {
-                                dstInd[1] = indE1;
-                                indE1++;
-
-                                if ( e2 != prevE2 )
+                                if ( e2 != prevE2 )
                                 {
                                     prevE2 = e2;
-                                    indE2++;
-                                }
-
-                                // ------------------
-                                srcInd[2] = 0; dstInd[2] = 0;
-                                size_t offsetSrc = x.calculate_offset(srcInd);
-                                size_t offsetDst = r.calculate_offset(dstInd);
-
-                                for ( cha=0; cha<CHA; cha++ )
-                                {
-                                    memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, ROLen);
-
-                                    offsetSrc += RO*E1;
-                                    offsetDst += RO*dstE1;
-                                }
-                                // ------------------
-                            }
-                        }
-                        // ------------------
-                    }
-                }
-            }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in extractSampledLinesUpTo11DArray(...) ... ");
-            return false;
-        }
-
-        return true;
-    }
-
-    template<typename T> 
-    bool fillSampledLinesUpTo11DArray(const hoNDArray<T>& x, hoNDArray<T>& r, const hoNDArray<float>& timeStamp)
-    {
-        try
-        {
-            size_t RO = x.get_size(0);
-            size_t E1 = timeStamp.get_size(1);
-            size_t CHA = x.get_size(2);
-            size_t SLC = timeStamp.get_size(3);
-            size_t E2 = timeStamp.get_size(4);
-            size_t CON = timeStamp.get_size(5);
-            size_t PHS = timeStamp.get_size(6);
-            size_t REP = timeStamp.get_size(7);
-            size_t SET = timeStamp.get_size(8);
-            size_t SEG = timeStamp.get_size(9);
-            size_t AVE = timeStamp.get_size(10);
-
-            size_t srcE1 = x.get_size(1);
-
-            size_t Num = AVE*SEG*SET*REP*PHS*SLC;
-
-            std::vector<size_t> dimRes;
-            timeStamp.get_dimensions(dimRes);
-
-            dimRes[0] = RO;
-            dimRes[2] = CHA;
-            r.create(&dimRes);
-            Gadgetron::clear(r);
-
-            size_t ROLen = sizeof(T)*RO;
-            hoNDArray<T> dummyArray(SLC, CON, PHS, REP, SET, SEG, AVE);
-
-            long long n;
-            #pragma omp parallel default(none) private(n) shared(Num, dummyArray, RO, E1, CHA, SLC, E2, CON, PHS, REP, SET, SEG, AVE, timeStamp, x, r, ROLen, srcE1)
-            {
-
-                std::vector<size_t> indN;
-                std::vector<size_t> srcInd(11, 0), dstInd(11, 0);
-                size_t e1, cha, slc, e2, con, rep, phs, set, seg, ave;
-
-                #pragma omp for
-                for ( n=0; n<(long long)Num; n++ )
-                {
-                    indN = dummyArray.calculate_index(n);
-
-                    ave = indN[6];
-                    seg = indN[5];
-                    set = indN[4];
-                    rep = indN[3];
-                    phs = indN[2];
-                    con = indN[1];
-                    slc = indN[0];
-
-                    srcInd[10] = ave; dstInd[10] = ave;
-                    srcInd[9] = seg; dstInd[9] = seg;
-                    srcInd[8] = set; dstInd[8] = set;
-                    srcInd[7] = rep; dstInd[7] = rep;
-                    srcInd[6] = phs; dstInd[6] = phs;
-                    srcInd[5] = con; dstInd[5] = con;
-                    srcInd[4] = slc; dstInd[4] = slc;
-
-                    // ------------------
-                    size_t indE2(0);
-                    size_t prevE2(0);
-                    for ( e2=0; e2<E2; e2++ )
-                    {
-                        srcInd[3] = indE2; dstInd[3] = e2;
-
-                        size_t indE1(0);
-                        for ( e1=0; e1<E1; e1++ )
-                        {
-                            dstInd[1] = e1; 
-
-                            dstInd[2] = 0;
-                            if ( timeStamp(dstInd) > 0 )
-                            {
-                                srcInd[1] = indE1;
-                                indE1++;
-
-                                if ( e2 != prevE2 )
-                                {
-                                    prevE2 = e2;
-                                    indE2++;
-                                }
-
-                                // ------------------
-
-                                srcInd[2] = 0; dstInd[2] = 0;
-                                size_t offsetSrc = x.calculate_offset(srcInd);
-                                size_t offsetDst = r.calculate_offset(dstInd);
-
-                                for ( cha=0; cha<CHA; cha++ )
-                                {
-                                    memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, ROLen);
-
-                                    offsetSrc += RO*srcE1;
-                                    offsetDst += RO*E1;
-                                }
-                                // ------------------
-                            }
-                        }
-                        // ------------------
-                    }
-                }
-            }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in fillSampledLinesUpTo11DArray(...) ... ");
-            return false;
-        }
-
-        return true;
-    }
-
-    template<typename T> 
-    bool stdOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& std, bool NMinusOne)
-    {
-        try
-        {
-            typedef typename realType<T>::Type value_type;
-
-            GADGET_DEBUG_CHECK_RETURN_FALSE(x.get_number_of_dimensions() >= 3);
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t CHA = x.get_size(2);
-
-            long long num = (long long)x.get_number_of_elements() / (RO*E1*CHA);
-
-            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
-
-            std::vector<size_t> dimStd(*dim);
-            dimStd.erase(dimStd.begin()+2);
-            std.create(&dimStd);
-
-            std::vector<size_t> dim3D(3);
-            dim3D[0] = RO;
-            dim3D[1] = E1;
-            dim3D[2] = CHA;
-
-            T S( (value_type)CHA );
-            if ( NMinusOne )
-            {
-                S = T( (value_type)CHA-1);
-            }
-
-            T v(0), v1(0);
-            T S2 = T( (value_type)1.0 )/S;
-            T S3 = T( (value_type)1.0 )/T( (value_type)CHA );
-
-            long long n;
-
-            #pragma omp parallel for default(none) private(n) shared(num, RO, E1, CHA, x, std, S, S2, S3, v, v1)
-            for ( n=0; n<num; n++ )
-            {
-                hoNDArray<T> xTmp(RO, E1, CHA, const_cast<T*>(x.begin()+n*RO*E1*CHA));
-                hoNDArray<T> mean(RO, E1);
-                Gadgetron::clear(mean);
-
-                size_t ro, e1, cha;
-                for ( cha=0; cha<CHA; cha++ )
-                {
-                    for ( e1=0; e1<E1; e1++ )
-                    {
-                        for ( ro=0; ro<RO; ro++ )
-                        {
-                            mean(ro+e1*RO) += xTmp(cha*RO*E1+e1*RO+ro)*S3;
-                        }
-                    }
-                }
-
-                for ( e1=0; e1<E1; e1++ )
-                {
-                    for ( ro=0; ro<RO; ro++ )
-                    {
-                        size_t ind = e1*RO+ro;
-
-                        v = 0; v1 = 0;
-                        for ( cha=0; cha<CHA; cha++ )
-                        {
-                            v1 = std::abs(xTmp(cha*RO*E1+ind)-mean(ind));
-                            v += v1*v1;
-                        }
-
-                        v /= S;
-                        std(ind+n*RO*E1) = std::sqrt(v);
-                    }
-                }
-            }
-        }
-        catch(...)
-        {
-            GERROR_STREAM("Errors in stdOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& std, bool NMinusOne) ... ");
-            return false;
-        }
-
-        return true;
-    }
-
-    template<typename T> 
-    bool cropOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-
-            size_t NDim = dimX->size();
-
-            if ( NDim <= 2 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t E2 = x.get_size(2);
-
-            size_t E2_R = end-start+1;
-
-            if ( E2 <= E2_R )
-            {
-                r = x;
-                return true;
-            }
-
-            std::vector<size_t> dimR(*dimX);
-            dimR[2] = E2_R;
-
-            r.create(&dimR);
-
-            size_t N2D = RO*E1;
-            size_t N3D = RO*E1*E2;
-            size_t N3D_R = RO*E1*E2_R;
-
-            size_t N = x.get_number_of_elements()/N3D;
-
-            const T* pX = x.begin();
-            T* pR = r.begin();
-
-            size_t n;
-            for ( n=0; n<N; n++ )
-            {
-                long long e2;
-                #pragma omp parallel for default(none) private(e2) shared(N2D, N3D, N3D_R, pX, pR, RO, E1, E2, n, start, end)
-                for ( e2=(long long)start; e2<=(long long)end; e2++ )
-                {
-                    memcpy(pR+n*N3D_R+(e2-start)*N2D, pX+n*N3D+e2*N2D, sizeof(T)*N2D);
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in cropOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> bool setSubArrayOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimR = r.get_dimensions();
-
-            size_t NDim = dimR->size();
-
-            if ( NDim <= 2 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t RO = r.get_size(0);
-            size_t E1 = r.get_size(1);
-            size_t E2 = r.get_size(2);
-
-            size_t E2_X = end-start+1;
-            GADGET_CHECK_RETURN_FALSE( E2_X == x.get_size(2) );
-
-            if ( E2_X >= E2 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t N2D = RO*E1;
-            size_t N3D = RO*E1*E2;
-            size_t N3D_X = RO*E1*E2_X;
-
-            size_t N = r.get_number_of_elements()/N3D;
-
-            const T* pX = x.begin();
-            T* pR = r.begin();
-
-            size_t n;
-            for ( n=0; n<N; n++ )
-            {
-                long long e2;
-                #pragma omp parallel for default(none) private(e2) shared(N2D, N3D, N3D_X, pX, pR, RO, E1, E2, n, start, end)
-                for ( e2=(long long)start; e2<=(long long)end; e2++ )
-                {
-                    memcpy(pR+n*N3D+e2*N2D, pX+n*N3D_X+(e2-start)*N2D, sizeof(T)*N2D);
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in setSubArrayOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> 
-    bool permuteE2To3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-
-            size_t NDim = dimX->size();
-
-            if ( NDim <= 5 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t CHA = x.get_size(2);
-            size_t SLC = x.get_size(3);
-            size_t E2 = x.get_size(4);
-
-            std::vector<size_t> dimR(*dimX);
-            dimR[2] = E2;
-            dimR[3] = CHA;
-            dimR[4] = SLC;
-
-            r.create(&dimR);
-
-            size_t N2D = RO*E1;
-            size_t N5D = RO*E1*CHA*E2*SLC;
-
-            size_t N = x.get_number_of_elements()/N5D;
-
-            const T* pX = x.begin();
-            T* pR = r.begin();
-
-            size_t n;
-            for ( n=0; n<N; n++ )
-            {
-                int e2;
-                #pragma omp parallel for default(none) private(e2) shared(N5D, N2D, pX, pR, CHA, SLC, E2, n)
-                for ( e2=0; e2<E2; e2++ )
-                {
-                    for ( size_t slc=0; slc<SLC; slc++ )
-                    {
-                        for ( size_t cha=0; cha<CHA; cha++ )
-                        {
-                            memcpy(pR+n*N5D+slc*CHA*E2*N2D+cha*E2*N2D+e2*N2D, pX+n*N5D+e2*SLC*CHA*N2D+slc*CHA*N2D+cha*N2D, sizeof(T)*N2D);
-                        }
-                    }
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in permuteE2To3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> 
-    bool permuteE2To5thDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-
-            size_t NDim = dimX->size();
-
-            if ( NDim < 5 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t E2 = x.get_size(2);
-            size_t CHA = x.get_size(3);
-            size_t SLC = x.get_size(4);
-
-            std::vector<size_t> dimR(*dimX);
-            dimR[2] = CHA;
-            dimR[3] = SLC;
-            dimR[4] = E2;
-
-            r.create(&dimR);
-
-            size_t N2D = RO*E1;
-            size_t N5D = RO*E1*CHA*E2*SLC;
-
-            size_t N = x.get_number_of_elements()/N5D;
-
-            const T* pX = x.begin();
-            T* pR = r.begin();
-
-            size_t n;
-            for ( n=0; n<N; n++ )
-            {
-                int e2;
-                #pragma omp parallel for default(none) private(e2) shared(N5D, N2D, pX, pR, CHA, SLC, E2, n)
-                for ( e2=0; e2<E2; e2++ )
-                {
-                    for ( size_t slc=0; slc<SLC; slc++ )
-                    {
-                        for ( size_t cha=0; cha<CHA; cha++ )
-                        {
-                            memcpy(pR+n*N5D+e2*SLC*CHA*N2D+slc*CHA*N2D+cha*N2D, pX+n*N5D+slc*CHA*E2*N2D+cha*E2*N2D+e2*N2D, sizeof(T)*N2D);
-                        }
-                    }
-                }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in permuteE2To5thDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> 
-    bool permuteROTo3rdDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-
-            size_t NDim = dimX->size();
-
-            if ( NDim < 3 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t E2 = x.get_size(2);
-
-            std::vector<size_t> dimR(*dimX);
-            dimR[0] = E1;
-            dimR[1] = E2;
-            dimR[2] = RO;
-
-            r.create(&dimR);
-
-            size_t N3D = RO*E1*E2;
-
-            size_t N = x.get_number_of_elements()/N3D;
+                                    indE2++;
+                                }
 
-            const T* pX = x.begin();
-            T* pR = r.begin();
+                                // ------------------
 
-            long long n;
+                                srcInd[2] = 0; dstInd[2] = 0;
+                                size_t offsetSrc = x.calculate_offset(srcInd);
+                                size_t offsetDst = r.calculate_offset(dstInd);
 
-            #pragma omp parallel for default(none) private(n) shared(RO, E1, E2, N, pR, N3D, pX)
-            for ( n=0; n<(long long)N; n++ )
-            {
-                T* pRn = pR + n*N3D;
-                T* pXn = const_cast<T*>(pX) + n*N3D;
+                                for ( cha=0; cha<CHA; cha++ )
+                                {
+                                    memcpy(r.begin()+offsetDst, x.begin()+offsetSrc, ROLen);
 
-                for ( size_t e2=0; e2<E2; e2++ )
-                {
-                    for ( size_t e1=0; e1<E1; e1++ )
-                    {
-                        for ( size_t ro=0; ro<RO; ro++ )
-                        {
-                            pRn[e1+e2*E1+ro*E1*E2] = pXn[ro+e1*RO+e2*RO*E1];
+                                    offsetSrc += RO*srcE1;
+                                    offsetDst += RO*E1;
+                                }
+                                // ------------------
+                            }
                         }
+                        // ------------------
                     }
                 }
             }
         }
-        catch (...)
+        catch(...)
         {
-            GERROR_STREAM("Errors in permuteROTo3rdDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
+            GERROR_STREAM("Errors in fillSampledLinesUpTo11DArray(...) ... ");
             return false;
         }
+
         return true;
     }
 
     template<typename T> 
-    bool permuteROTo4thDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r)
+    bool stdOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& std, bool NMinusOne)
     {
         try
         {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-
-            size_t NDim = dimX->size();
+            typedef typename realType<T>::Type value_type;
 
-            if ( NDim < 4 )
-            {
-                r = x;
-                return true;
-            }
+            GADGET_DEBUG_CHECK_RETURN_FALSE(x.get_number_of_dimensions() >= 3);
 
             size_t RO = x.get_size(0);
             size_t E1 = x.get_size(1);
-            size_t E2 = x.get_size(2);
-            size_t CHA = x.get_size(3);
+            size_t CHA = x.get_size(2);
 
-            std::vector<size_t> dimR(*dimX);
-            dimR[0] = E1;
-            dimR[1] = E2;
-            dimR[2] = CHA;
-            dimR[3] = RO;
+            long long num = (long long)x.get_number_of_elements() / (RO*E1*CHA);
 
-            r.create(&dimR);
+            boost::shared_ptr< std::vector<size_t> > dim = x.get_dimensions();
+
+            std::vector<size_t> dimStd(*dim);
+            dimStd.erase(dimStd.begin()+2);
+            std.create(&dimStd);
 
-            size_t N4D = RO*E1*E2*CHA;
+            std::vector<size_t> dim3D(3);
+            dim3D[0] = RO;
+            dim3D[1] = E1;
+            dim3D[2] = CHA;
 
-            size_t N = x.get_number_of_elements()/N4D;
+            T S( (value_type)CHA );
+            if ( NMinusOne )
+            {
+                S = T( (value_type)CHA-1);
+            }
 
-            const T* pX = x.begin();
-            T* pR = r.begin();
+            T v(0), v1(0);
+            T S2 = T( (value_type)1.0 )/S;
+            T S3 = T( (value_type)1.0 )/T( (value_type)CHA );
 
             long long n;
-            for ( n=0; n<(long long)N; n++ )
-            {
-                T* pRn = pR + n*N4D;
-                T* pXn = const_cast<T*>(pX) + n*N4D;
 
-                long long cha;
+            #pragma omp parallel for default(none) private(n) shared(num, RO, E1, CHA, x, std, S, S2, S3, v, v1)
+            for ( n=0; n<num; n++ )
+            {
+                hoNDArray<T> xTmp(RO, E1, CHA, const_cast<T*>(x.begin()+n*RO*E1*CHA));
+                hoNDArray<T> mean(RO, E1);
+                Gadgetron::clear(mean);
 
-                #pragma omp parallel for default(none) private(cha) shared(RO, E1, E2, CHA, pXn, pRn)
-                for ( cha=0; cha<(long long)CHA; cha++ )
+                size_t ro, e1, cha;
+                for ( cha=0; cha<CHA; cha++ )
                 {
-                    for ( size_t e2=0; e2<E2; e2++ )
+                    for ( e1=0; e1<E1; e1++ )
                     {
-                        for ( size_t e1=0; e1<E1; e1++ )
+                        for ( ro=0; ro<RO; ro++ )
                         {
-                            for ( size_t ro=0; ro<RO; ro++ )
-                            {
-                                pRn[e1+e2*E1+cha*E1*E2+ro*E1*E2*CHA] = pXn[ro+e1*RO+e2*RO*E1+cha*RO*E1*E2];
-                            }
+                            mean(ro+e1*RO) += xTmp(cha*RO*E1+e1*RO+ro)*S3;
                         }
                     }
                 }
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in permuteROTo4thDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
-            return false;
-        }
-        return true;
-    }
-
-    template<typename T> 
-    bool permuteROTo1stDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r)
-    {
-        try
-        {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
-
-            size_t NDim = dimX->size();
-
-            if ( NDim < 4 )
-            {
-                r = x;
-                return true;
-            }
-
-            size_t E1 = x.get_size(0);
-            size_t E2 = x.get_size(1);
-            size_t CHA = x.get_size(2);
-            size_t RO = x.get_size(3);
-
-            std::vector<size_t> dimR(*dimX);
-            dimR[0] = RO;
-            dimR[1] = E1;
-            dimR[2] = E2;
-            dimR[3] = CHA;
-
-            r.create(&dimR);
-
-            size_t N4D = RO*E1*E2*CHA;
-
-            size_t N = x.get_number_of_elements()/N4D;
-
-            const T* pX = x.begin();
-            T* pR = r.begin();
-
-            long long n;
-            for ( n=0; n<(long long)N; n++ )
-            {
-                T* pRn = pR + n*N4D;
-                T* pXn = const_cast<T*>(pX) + n*N4D;
-
-                long long cha;
 
-                #pragma omp parallel for default(none) private(cha) shared(RO, E1, E2, CHA, pXn, pRn)
-                for ( cha=0; cha<(long long)CHA; cha++ )
+                for ( e1=0; e1<E1; e1++ )
                 {
-                    for ( size_t e2=0; e2<E2; e2++ )
+                    for ( ro=0; ro<RO; ro++ )
                     {
-                        for ( size_t e1=0; e1<E1; e1++ )
+                        size_t ind = e1*RO+ro;
+
+                        v = 0; v1 = 0;
+                        for ( cha=0; cha<CHA; cha++ )
                         {
-                            size_t indRn = e1*RO+e2*RO*E1+cha*RO*E1*E2;
-                            size_t indXn = e1+e2*E1+cha*E1*E2;
-                            for ( size_t ro=0; ro<RO; ro++ )
-                            {
-                                pRn[ro+indRn] = pXn[indXn+ro*E1*E2*CHA];
-                            }
+                            v1 = std::abs(xTmp(cha*RO*E1+ind)-mean(ind));
+                            v += v1*v1;
                         }
+
+                        v /= S;
+                        std(ind+n*RO*E1) = std::sqrt(v);
                     }
                 }
             }
         }
-        catch (...)
+        catch(...)
         {
-            GERROR_STREAM("Errors in permuteROTo1stDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
+            GERROR_STREAM("Errors in stdOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& std, bool NMinusOne) ... ");
             return false;
         }
+
         return true;
     }
 
     template<typename T> 
-    bool permute3rdDimensionTo1stDimension(const hoNDArray<T>& x, hoNDArray<T>& r)
+    bool cropOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end)
     {
         try
         {
@@ -1916,7 +548,7 @@ namespace Gadgetron {
 
             size_t NDim = dimX->size();
 
-            if ( NDim < 3 )
+            if ( NDim <= 2 )
             {
                 r = x;
                 return true;
@@ -1926,128 +558,109 @@ namespace Gadgetron {
             size_t E1 = x.get_size(1);
             size_t E2 = x.get_size(2);
 
+            size_t E2_R = end-start+1;
+
+            if ( E2 <= E2_R )
+            {
+                r = x;
+                return true;
+            }
+
             std::vector<size_t> dimR(*dimX);
-            dimR[0] = E2;
-            dimR[1] = RO;
-            dimR[2] = E1;
+            dimR[2] = E2_R;
 
             r.create(&dimR);
 
+            size_t N2D = RO*E1;
             size_t N3D = RO*E1*E2;
+            size_t N3D_R = RO*E1*E2_R;
 
             size_t N = x.get_number_of_elements()/N3D;
 
             const T* pX = x.begin();
             T* pR = r.begin();
 
-            long long n, e2;
-            for ( n=0; n<(long long)N; n++ )
+            size_t n;
+            for ( n=0; n<N; n++ )
             {
-                T* pRn = pR + n*N3D;
-                T* pXn = const_cast<T*>(pX) + n*N3D;
-
-                #pragma omp parallel for default(none) private(e2) shared(RO, E1, E2, pXn, pRn)
-                for ( e2=0; e2<(long long)E2; e2++ )
+                long long e2;
+                #pragma omp parallel for default(none) private(e2) shared(N2D, N3D, N3D_R, pX, pR, RO, E1, E2, n, start, end)
+                for ( e2=(long long)start; e2<=(long long)end; e2++ )
                 {
-                    for ( size_t e1=0; e1<E1; e1++ )
-                    {
-                        size_t indRn = e2+e1*E2*RO;
-                        size_t indXn = e1*RO+e2*RO*E1;
-                        for ( size_t ro=0; ro<RO; ro++ )
-                        {
-                            pRn[ro*E2+indRn] = pXn[ro+indXn];
-                        }
-                    }
+                    memcpy(pR+n*N3D_R+(e2-start)*N2D, pX+n*N3D+e2*N2D, sizeof(T)*N2D);
                 }
             }
         }
         catch (...)
         {
-            GERROR_STREAM("Errors in permute3rdDimensionTo1stDimension(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
+            GERROR_STREAM("Errors in cropOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end) ... ");
             return false;
         }
         return true;
     }
 
-    template<typename T> 
-    bool permuteROTo5thDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r)
+    template<typename T> bool setSubArrayOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end)
     {
         try
         {
-            boost::shared_ptr< std::vector<size_t> > dimX = x.get_dimensions();
+            boost::shared_ptr< std::vector<size_t> > dimR = r.get_dimensions();
 
-            size_t NDim = dimX->size();
+            size_t NDim = dimR->size();
 
-            if ( NDim < 5 )
+            if ( NDim <= 2 )
             {
                 r = x;
                 return true;
             }
 
-            size_t RO = x.get_size(0);
-            size_t E1 = x.get_size(1);
-            size_t E2 = x.get_size(2);
-            size_t srcCHA = x.get_size(3);
-            size_t dstCHA = x.get_size(4);
+            size_t RO = r.get_size(0);
+            size_t E1 = r.get_size(1);
+            size_t E2 = r.get_size(2);
 
-            std::vector<size_t> dimR(*dimX);
-            dimR[0] = E1;
-            dimR[1] = E2;
-            dimR[2] = srcCHA;
-            dimR[3] = dstCHA;
-            dimR[4] = RO;
+            size_t E2_X = end-start+1;
+            GADGET_CHECK_RETURN_FALSE( E2_X == x.get_size(2) );
 
-            r.create(&dimR);
+            if ( E2_X >= E2 )
+            {
+                r = x;
+                return true;
+            }
 
-            size_t N5D = RO*E1*E2*srcCHA*dstCHA;
+            size_t N2D = RO*E1;
+            size_t N3D = RO*E1*E2;
+            size_t N3D_X = RO*E1*E2_X;
 
-            size_t N = x.get_number_of_elements()/N5D;
+            size_t N = r.get_number_of_elements()/N3D;
 
             const T* pX = x.begin();
             T* pR = r.begin();
 
-            long long n;
-            for ( n=0; n<(long long)N; n++ )
+            size_t n;
+            for ( n=0; n<N; n++ )
             {
-                T* pRn = pR + n*N5D;
-                T* pXn = const_cast<T*>(pX) + n*N5D;
-
-                long long dcha;
-
-                #pragma omp parallel for default(none) private(dcha) shared(RO, E1, E2, srcCHA, dstCHA, pXn, pRn)
-                for ( dcha=0; dcha<(long long)dstCHA; dcha++ )
+                long long e2;
+                #pragma omp parallel for default(none) private(e2) shared(N2D, N3D, N3D_X, pX, pR, RO, E1, E2, n, start, end)
+                for ( e2=(long long)start; e2<=(long long)end; e2++ )
                 {
-                    for ( size_t scha=0; scha<(int)srcCHA; scha++ )
-                    {
-                        for ( size_t e2=0; e2<E2; e2++ )
-                        {
-                            for ( size_t e1=0; e1<E1; e1++ )
-                            {
-                                size_t indRn = e1+e2*E1+scha*E1*E2+dcha*E1*E2*srcCHA;
-                                size_t indXn = e1*RO+e2*RO*E1+scha*RO*E1*E2+dcha*RO*E1*E2*srcCHA;
-                                for ( size_t ro=0; ro<RO; ro++ )
-                                {
-                                    pRn[indRn+ro*E1*E2*srcCHA*dstCHA] = pXn[ro+indXn];
-                                }
-                            }
-                        }
-                    }
+                    memcpy(pR+n*N3D+e2*N2D, pX+n*N3D_X+(e2-start)*N2D, sizeof(T)*N2D);
                 }
             }
         }
         catch (...)
         {
-            GERROR_STREAM("Errors in permuteROTo5thDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r) ... ");
+            GERROR_STREAM("Errors in setSubArrayOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r, size_t start, size_t end) ... ");
             return false;
         }
         return true;
     }
 
-    template<typename T> 
+    template<typename T>
     bool imageDomainUnwrapping2D(const hoNDArray<T>& x, const hoNDArray<T>& kernel, hoNDArray<T>& buf, hoNDArray<T>& y)
     {
         try
         {
+            typedef typename realType<T>::Type value_type;
+
             T* pX = const_cast<T*>(x.begin());
             T* ker = const_cast<T*>(kernel.begin());
             T* pY = y.begin();
@@ -2057,7 +670,7 @@ namespace Gadgetron {
             size_t srcCHA = x.get_size(2);
             size_t dstCHA = kernel.get_size(3);
 
-            if ( buf.get_number_of_elements() < ro*e1*srcCHA )
+            if (buf.get_number_of_elements() < ro*e1*srcCHA)
             {
                 buf.create(ro, e1, srcCHA);
             }
@@ -2070,28 +683,48 @@ namespace Gadgetron {
                 //#ifdef WIN32
                 //    int tid = omp_get_thread_num();
                 //    DWORD_PTR mask = (1 << tid);
-                //    // GDEBUG_STREAM("thread id : " << tid << " - mask : " << mask);
+                //    // GADGET_MSG("thread id : " << tid << " - mask : " << mask);
                 //    SetThreadAffinityMask( GetCurrentThread(), mask );
                 //#endif // WIN32
 
                 //#pragma omp for
 
-                for ( dCha=0; dCha<dstCHA; dCha++ )
+                for (dCha = 0; dCha<dstCHA; dCha++)
                 {
-                    multiplyCplx(ro*e1*srcCHA, pX, ker+dCha*ro*e1*srcCHA, pBuf);
+                    // multiplyCplx(ro*e1*srcCHA, pX, ker+dCha*ro*e1*srcCHA, pBuf);
 
-                    memcpy(pY+dCha*ro*e1, pBuf, sizeof(T)*ro*e1);
-                    for ( size_t sCha=1; sCha<srcCHA; sCha++ )
+                    long long N = ro*e1*srcCHA;
+                    T* x = pX;
+                    T* y = ker + dCha*ro*e1*srcCHA;
+                    T* r = pBuf;
+
+                    long long n;
+#pragma omp parallel for default(none) private(n) shared(N, x, y, r) if (N>64*1024)
+                    for (n = 0; n < (long long)N; n++)
+                    {
+                        const T& a1 = x[n];
+                        const T& b1 = y[n];
+                        const value_type a = a1.real();
+                        const value_type b = a1.imag();
+                        const value_type c = b1.real();
+                        const value_type d = b1.imag();
+
+                        reinterpret_cast<value_type(&)[2]>(r[n])[0] = a*c - b*d;
+                        reinterpret_cast<value_type(&)[2]>(r[n])[1] = a*d + b*c;
+                    }
+
+                    memcpy(pY + dCha*ro*e1, pBuf, sizeof(T)*ro*e1);
+                    for (size_t sCha = 1; sCha<srcCHA; sCha++)
                     {
                         // Gadgetron::math::add(ro*e1, pY+dCha*ro*e1, pBuf+sCha*ro*e1, pY+dCha*ro*e1);
 
                         size_t ii;
-                        size_t N2D=ro*e1;
+                        size_t N2D = ro*e1;
 
-                        T* pY2D = pY+dCha*ro*e1;
-                        T* pBuf2D = pBuf+sCha*ro*e1;
+                        T* pY2D = pY + dCha*ro*e1;
+                        T* pBuf2D = pBuf + sCha*ro*e1;
 
-                        for ( ii=0; ii<N2D; ii++ )
+                        for (ii = 0; ii<N2D; ii++)
                         {
                             pY2D[ii] += pBuf2D[ii];
                         }
@@ -2107,120 +740,6 @@ namespace Gadgetron {
         return true;
     }
 
-    template<typename T> 
-    bool imageDomainUnwrapping2DT(const hoNDArray<T>& x, const hoNDArray<T>& kernel, hoNDArray<T>& buf, hoNDArray<T>& y)
-    {
-        try
-        {
-            long long ro = (long long)x.get_size(0);
-            long long e1 = (long long)x.get_size(1);
-            long long srcCHA = (long long)x.get_size(2);
-            long long N = (long long)x.get_size(3);
-
-            long long dstCHA = (long long)kernel.get_size(3);
-            long long kerN = (long long)kernel.get_size(4);
-
-            if ( (long long)buf.get_number_of_elements() < ro*e1*srcCHA )
-            {
-                buf.create(ro, e1, srcCHA);
-            }
-            T* pBuf = buf.begin();
-
-            long long n, dCha;
-
-            //#pragma omp parallel default(shared)
-            {
-                //#ifdef WIN32
-                //    int tid = omp_get_thread_num();
-                //    DWORD_PTR mask = (1 << tid);
-                //    // GDEBUG_STREAM("thread id : " << tid << " - mask : " << mask);
-                //    SetThreadAffinityMask( GetCurrentThread(), mask );
-                //#endif // WIN32
-
-                //#pragma omp for
-
-                //if ( typeid(T)==typeid( std::complex<float> ) )
-                //{
-                    const T* pXN = x.begin();
-                    T* pYN = y.begin();
-                    T* pBufN = buf.begin();
-                    const T* pKerN = kernel.begin();
-
-                    // #pragma omp parallel for default(none) private(dCha, n) shared(N, ro, e1, srcCHA, dstCHA, kerN, pXN, pYN, pBufN, pKerN)
-                    for ( dCha=0; dCha<(long long)dstCHA; dCha++ )
-                    {
-                        for ( n=0; n<N; n++  )
-                        {
-                            const T* ker = pKerN + n*ro*e1*srcCHA*dstCHA;
-                            if ( kerN <= n )
-                            {
-                                ker = pKerN + (kerN-1)*ro*e1*srcCHA*dstCHA;
-                            }
-
-                            const T* pX = pXN + n*ro*e1*srcCHA;
-                            T* pBuf =pBufN + n*ro*e1*srcCHA;
-
-                            multiplyCplx(ro*e1*srcCHA, pX, ker+dCha*ro*e1*srcCHA, pBuf);
-                        //}
-
-                        //for ( n=0; n<N; n++  )
-                        //{
-                            T* pY = pYN + n*ro*e1*dstCHA;
-                            //T* pBuf =pBufN + n*ro*e1*srcCHA;
-
-                            memcpy(pY+dCha*ro*e1, pBuf, sizeof(T)*ro*e1);
-                            for ( long long sCha=1; sCha<srcCHA; sCha++ )
-                            {
-                                // Gadgetron::math::add(ro*e1, pY+dCha*ro*e1, pBuf+sCha*ro*e1, pY+dCha*ro*e1);
-                                size_t ii;
-                                size_t N2D=ro*e1;
-
-                                T* pY2D = pY+dCha*ro*e1;
-                                T* pBuf2D = pBuf+sCha*ro*e1;
-
-                                for ( ii=0; ii<N2D; ii++ )
-                                {
-                                    pY2D[ii] += pBuf2D[ii];
-                                }
-                            }
-                        }
-                    }
-                //}
-                //else if ( typeid(T)==typeid( std::complex<double> ) )
-                //{
-                //    for ( n=0; n<N; n++ )
-                //    {
-                //        const T* ker = kernel.begin() + n*ro*e1*srcCHA*dstCHA;
-                //        if ( kerN <= n )
-                //        {
-                //            ker = kernel.begin() + (kerN-1)*ro*e1*srcCHA*dstCHA;
-                //        }
-
-                //        const T* pX = x.begin() + n*ro*e1*srcCHA;
-                //        T* pY = y.begin() + n*ro*e1*dstCHA;
-
-                //        for ( long long dCha=0; dCha<dstCHA; dCha++ )
-                //        {
-                //            Gadgetron::math::multiply(ro*e1*srcCHA, pX, ker+dCha*ro*e1*srcCHA, pBuf);
-
-                //            memcpy(pY+dCha*ro*e1, pBuf, sizeof(T)*ro*e1);
-                //            for ( long long sCha=1; sCha<srcCHA; sCha++ )
-                //            {
-                //                Gadgetron::math::add(ro*e1, pY+dCha*ro*e1, pBuf+sCha*ro*e1, pY+dCha*ro*e1);
-                //            }
-                //        }
-                //    }
-                //}
-            }
-        }
-        catch (...)
-        {
-            GERROR_STREAM("Errors in imageDomainUnwrapping2DT(const hoNDArray<T>& x, const hoNDArray<T>& ker, hoNDArray<T>& buf, hoNDArray<T>& y) ... ");
-            return false;
-        }
-        return true;
-    }
-
     template<typename CoordType, typename T> 
     bool computePeriodicBoundaryValues(const hoNDArray<CoordType>& x, const hoNDArray<T>& y, CoordType start, CoordType end, hoNDArray<CoordType>& vx, hoNDArray<T>& vy)
     {
@@ -2283,86 +802,6 @@ namespace Gadgetron {
         return true;
     }
 
-    template EXPORTGTPLUS bool sumOverLastDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOverLastDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOverLastDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOverLastDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool sumOverSecondLastDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOverSecondLastDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOverSecondLastDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOverSecondLastDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool multiplyOverLastDimension(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool multiplyOverLastDimension(const hoNDArray<double>& x, const hoNDArray<double>& y, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool multiplyOverLastDimension(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& y, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool multiplyOverLastDimension(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& y, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool divideOverLastDimension(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool divideOverLastDimension(const hoNDArray<double>& x, const hoNDArray<double>& y, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool divideOverLastDimension(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& y, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool divideOverLastDimension(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& y, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool sumOver1stDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOver1stDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOver1stDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOver1stDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool sumOver2ndDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOver2ndDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOver2ndDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOver2ndDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool sumOver3rdDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOver3rdDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOver3rdDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOver3rdDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool sumOver4thDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOver4thDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOver4thDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOver4thDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool sumOver5thDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool sumOver5thDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool sumOver5thDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool sumOver5thDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool multiplyOver3rdDimension(const hoNDArray<float>& x3D, const hoNDArray<float>& y4D, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool multiplyOver3rdDimension(const hoNDArray<double>& x3D, const hoNDArray<double>& y4D, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool multiplyOver3rdDimension(const hoNDArray< std::complex<float> >& x3D, const hoNDArray< std::complex<float> >& y4D, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool multiplyOver3rdDimension(const hoNDArray< std::complex<double> >& x3D, const hoNDArray< std::complex<double> >& y4D, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool multiplyOver4thDimension(const hoNDArray<float>& x4D, const hoNDArray<float>& y5D, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool multiplyOver4thDimension(const hoNDArray<double>& x4D, const hoNDArray<double>& y5D, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool multiplyOver4thDimension(const hoNDArray< std::complex<float> >& x4D, const hoNDArray< std::complex<float> >& y5D, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool multiplyOver4thDimension(const hoNDArray< std::complex<double> >& x4D, const hoNDArray< std::complex<double> >& y5D, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool multiplyOver4thDimensionExcept(const hoNDArray<float>& x4D, const hoNDArray<float>& y5D, size_t n, hoNDArray<float>& r, bool copyY2R);
-    template EXPORTGTPLUS bool multiplyOver4thDimensionExcept(const hoNDArray<double>& x4D, const hoNDArray<double>& y5D, size_t n, hoNDArray<double>& r, bool copyY2R);
-    template EXPORTGTPLUS bool multiplyOver4thDimensionExcept(const hoNDArray< std::complex<float> >& x4D, const hoNDArray< std::complex<float> >& y5D, size_t n, hoNDArray< std::complex<float> >& r, bool copyY2R);
-    template EXPORTGTPLUS bool multiplyOver4thDimensionExcept(const hoNDArray< std::complex<double> >& x4D, const hoNDArray< std::complex<double> >& y5D, size_t n, hoNDArray< std::complex<double> >& r, bool copyY2R);
-
-    template EXPORTGTPLUS bool multiplyOver5thDimension(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool multiplyOver5thDimension(const hoNDArray<double>& x, const hoNDArray<double>& y, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool multiplyOver5thDimension(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& y, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool multiplyOver5thDimension(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& y, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool multiplyOver5thDimensionExcept(const hoNDArray<float>& x, const hoNDArray<float>& y, size_t n, hoNDArray<float>& r, bool copyY2R);
-    template EXPORTGTPLUS bool multiplyOver5thDimensionExcept(const hoNDArray<double>& x, const hoNDArray<double>& y, size_t n, hoNDArray<double>& r, bool copyY2R);
-    template EXPORTGTPLUS bool multiplyOver5thDimensionExcept(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& y, size_t n, hoNDArray< std::complex<float> >& r, bool copyY2R);
-    template EXPORTGTPLUS bool multiplyOver5thDimensionExcept(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& y, size_t n, hoNDArray< std::complex<double> >& r, bool copyY2R);
-
-    template EXPORTGTPLUS bool multipleAdd(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool multipleAdd(const hoNDArray<double>& x, const hoNDArray<double>& y, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool multipleAdd(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& y, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool multipleAdd(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& y, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool multipleMultiply(const hoNDArray<float>& x, const hoNDArray<float>& y, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool multipleMultiply(const hoNDArray<double>& x, const hoNDArray<double>& y, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool multipleMultiply(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& y, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool multipleMultiply(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& y, hoNDArray< std::complex<double> >& r);
-
     template EXPORTGTPLUS bool cropUpTo11DArray(const hoNDArray<short>& x, hoNDArray<short>& r, const std::vector<size_t>& start, std::vector<size_t>& size);
     template EXPORTGTPLUS bool cropUpTo11DArray(const hoNDArray<unsigned short>& x, hoNDArray<unsigned short>& r, const std::vector<size_t>& start, std::vector<size_t>& size);
     template EXPORTGTPLUS bool cropUpTo11DArray(const hoNDArray<float>& x, hoNDArray<float>& r, const std::vector<size_t>& start, std::vector<size_t>& size);
@@ -2410,47 +849,9 @@ namespace Gadgetron {
     template EXPORTGTPLUS bool stdOver3rdDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& std, bool NMinusOne);
     template EXPORTGTPLUS bool stdOver3rdDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& std, bool NMinusOne);
 
-    template EXPORTGTPLUS bool permuteE2To3rdDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permuteE2To3rdDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permuteE2To3rdDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permuteE2To3rdDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool permuteE2To5thDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permuteE2To5thDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permuteE2To5thDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permuteE2To5thDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool permuteROTo3rdDimensionFor3DRecon(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permuteROTo3rdDimensionFor3DRecon(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permuteROTo3rdDimensionFor3DRecon(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permuteROTo3rdDimensionFor3DRecon(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool permuteROTo4thDimensionFor3DRecon(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permuteROTo4thDimensionFor3DRecon(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permuteROTo4thDimensionFor3DRecon(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permuteROTo4thDimensionFor3DRecon(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool permuteROTo1stDimensionFor3DRecon(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permuteROTo1stDimensionFor3DRecon(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permuteROTo1stDimensionFor3DRecon(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permuteROTo1stDimensionFor3DRecon(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool permute3rdDimensionTo1stDimension(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permute3rdDimensionTo1stDimension(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permute3rdDimensionTo1stDimension(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permute3rdDimensionTo1stDimension(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
-    template EXPORTGTPLUS bool permuteROTo5thDimensionFor3DRecon(const hoNDArray<float>& x, hoNDArray<float>& r);
-    template EXPORTGTPLUS bool permuteROTo5thDimensionFor3DRecon(const hoNDArray<double>& x, hoNDArray<double>& r);
-    template EXPORTGTPLUS bool permuteROTo5thDimensionFor3DRecon(const hoNDArray< std::complex<float> >& x, hoNDArray< std::complex<float> >& r);
-    template EXPORTGTPLUS bool permuteROTo5thDimensionFor3DRecon(const hoNDArray< std::complex<double> >& x, hoNDArray< std::complex<double> >& r);
-
     template EXPORTGTPLUS bool imageDomainUnwrapping2D(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& ker, hoNDArray< std::complex<float> >& buf, hoNDArray< std::complex<float> >& y);
     template EXPORTGTPLUS bool imageDomainUnwrapping2D(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& ker, hoNDArray< std::complex<double> >& buf, hoNDArray< std::complex<double> >& y);
 
-    template EXPORTGTPLUS bool imageDomainUnwrapping2DT(const hoNDArray< std::complex<float> >& x, const hoNDArray< std::complex<float> >& ker, hoNDArray< std::complex<float> >& buf, hoNDArray< std::complex<float> >& y);
-    template EXPORTGTPLUS bool imageDomainUnwrapping2DT(const hoNDArray< std::complex<double> >& x, const hoNDArray< std::complex<double> >& ker, hoNDArray< std::complex<double> >& buf, hoNDArray< std::complex<double> >& y);
-
     template EXPORTGTPLUS bool computePeriodicBoundaryValues(const hoNDArray<float>& x, const hoNDArray<float>& y, float start, float end, hoNDArray<float>& vx, hoNDArray<float>& vy);
     template EXPORTGTPLUS bool computePeriodicBoundaryValues(const hoNDArray<float>& x, const hoNDArray<double>& y, float start, float end, hoNDArray<float>& vx, hoNDArray<double>& vy);
     template EXPORTGTPLUS bool computePeriodicBoundaryValues(const hoNDArray<float>& x, const hoNDArray< std::complex<float> >& y, float start, float end, hoNDArray<float>& vx, hoNDArray< std::complex<float> >& vy);
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconUtil.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconUtil.h
@@ -212,85 +212,6 @@ namespace Gadgetron {
 namespace Gadgetron {
 
     /**
-    * @brief sum over last dimension of an array
-             e.g. for a 4D array, sum over the 4th dimension and get a 3D array
-    */
-    template<typename T> EXPORTGTPLUS bool sumOverLastDimension(const hoNDArray<T>& x, hoNDArray<T>& r); // 
-
-    /**
-    * @brief sum over the second last dimension of an array
-             e.g. for a 4D array, sum over the 3rd dimension and get a 3D array
-    */
-    template<typename T> EXPORTGTPLUS bool sumOverSecondLastDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief multiply over the last dimension of y by x
-             e.g. x is 3D and y is 4D array, r(:,:,:,n) = y(:,:,:,n) .* x
-    */
-    template<typename T> EXPORTGTPLUS bool multiplyOverLastDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r);
-
-    /**
-    * @brief divide the last dimension of y by x
-             e.g. x is 3D and y is 4D array, r(:,:,:,n) = y(:,:,:,n) ./ x
-    */
-    template<typename T> EXPORTGTPLUS bool divideOverLastDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r);
-
-    /**
-    * @brief sum over the 1st dimension of an array
-             e.g. for a 2D array, sum over the 1st dimension and get an array of [1 E1]
-    */
-    template<typename T> EXPORTGTPLUS bool sumOver1stDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief sum over the 2nd dimension of an array
-             e.g. for a 3D array, sum over the 2nd dimension and get an array of [RO 1 CHA]
-    */
-    template<typename T> EXPORTGTPLUS bool sumOver2ndDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief sum over the 3rd dimension of an array
-             e.g. for a 4D array, sum over the 3rd dimension and get an array of [RO E1 1 N]
-    */
-    template<typename T> EXPORTGTPLUS bool sumOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief sum over the 4th dimension of an array
-             e.g. for a 5D array [RO E1 CHA N S], sum over the 4th dimension and get an array of [RO E1 CHA 1 S]
-    */
-    template<typename T> EXPORTGTPLUS bool sumOver4thDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief sum over the 5th dimension of an array
-             e.g. for a 6D array, sum over the 5th dimension and get an array [RO E1 CHA N 1 P]
-    */
-    template<typename T> EXPORTGTPLUS bool sumOver5thDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief multiply over the 3rd/4th/5th dimension of y by x
-             e.g. x is 3D and y is 4D array, r(:,:,n,:) = y(:,:,n,:) .* x
-             e.g. x is 4D and y is 5D array, r(:,:,:,n,:) = y(:,:,:,n,:) .* x
-             e.g. x is 5D and y is 6D array, r(:,:,:,:, n,:) = y(:,:,:,:,n,:) .* x
-    */
-    template<typename T> EXPORTGTPLUS bool multiplyOver3rdDimension(const hoNDArray<T>& x3D, const hoNDArray<T>& y4D, hoNDArray<T>& r);
-    template<typename T> EXPORTGTPLUS bool multiplyOver4thDimension(const hoNDArray<T>& x4D, const hoNDArray<T>& y5D, hoNDArray<T>& r);
-    template<typename T> EXPORTGTPLUS bool multiplyOver5thDimension(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r);
-
-    /**
-    * @brief multiply over the 4th/5th dimension of y by x except for dimension index n
-             e.g. x is 4D and y is 5D array, r(:,:,:,t,:) = y(:,:,:,t,:) .* x, except for r(:,:,:,n,:) = y(:,:,:,n,:)
-             e.g. x is 5D and y is 6D array, r(:,:,:,:,t,:) = y(:,:,:,:,t,:) .* x, except for r(:,:,:,:,n,:) = y(:,:,:,:,n,:)
-    */
-    template<typename T> EXPORTGTPLUS bool multiplyOver4thDimensionExcept(const hoNDArray<T>& x4D, const hoNDArray<T>& y5D, size_t n, hoNDArray<T>& r, bool copyY2R=true);
-    template<typename T> EXPORTGTPLUS bool multiplyOver5thDimensionExcept(const hoNDArray<T>& x, const hoNDArray<T>& y, size_t n, hoNDArray<T>& r, bool copyY2R=true);
-
-    /**
-    * @brief r = x add/multiply/divide y for every part of y
-    */
-    template<typename T> EXPORTGTPLUS bool multipleAdd(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r);
-    template<typename T> EXPORTGTPLUS bool multipleMultiply(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r);
-    template<typename T> EXPORTGTPLUS bool multipleDivide(const hoNDArray<T>& x, const hoNDArray<T>& y, hoNDArray<T>& r);
-
-    /**
     * @brief copy the sub-array of x to r
              the sub-array is defined by its starting index and array size
     */
@@ -334,46 +255,6 @@ namespace Gadgetron {
     template<typename T> EXPORTGTPLUS bool stdOver3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& std, bool NMinusOne);
 
     /**
-    * @brief permute E2 dimension of x : [RO E1 CHA SLC E2 ...] to r: [RO E1 E2 CHA SLC ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permuteE2To3rdDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief permute E2 dimension of x : [RO E1 E2 CHA SLC ...] to r: [RO E1 CHA SLC E2 ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permuteE2To5thDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief permute RO dimension of x to the 3rd dimension
-             x : [RO E1 E2 ...], r: [E1 E2 RO ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permuteROTo3rdDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief permute RO dimension of x to the 4th dimension
-             x : [RO E1 E2 CHA ...], r: [E1 E2 CHA RO ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permuteROTo4thDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief permute RO dimension of x back to the 1st dimension
-             x : [E1 E2 CHA RO ...], r: [RO E1 E2 CHA ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permuteROTo1stDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief permute the 3rd dimension of x to the 1st dimension
-             x : [RO E1 E2 CHA ...], r: [E2 RO E1 CHA ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permute3rdDimensionTo1stDimension(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
-    * @brief permute RO dimension of x to the 5th dimension
-             x : [RO E1 E2 srcCHA dstCHA ...], r: [E1 E2 srcCHA dstCHA RO ...]
-    */
-    template<typename T> EXPORTGTPLUS bool permuteROTo5thDimensionFor3DRecon(const hoNDArray<T>& x, hoNDArray<T>& r);
-
-    /**
     * @brief Image domain unwrapping for 2D
              x : [RO E1 srcCHA], ker [RO E1 srcCHA dstCHA]
              buf is a buffer for computer, need to be pre-allocated [RO E1 srcCHA], y [RO E1 dstCHA]
@@ -382,14 +263,6 @@ namespace Gadgetron {
     template<typename T> EXPORTGTPLUS bool imageDomainUnwrapping2D(const hoNDArray<T>& x, const hoNDArray<T>& ker, hoNDArray<T>& buf, hoNDArray<T>& y);
 
     /**
-    * @brief Image domain unwrapping for 2D
-             x : [RO E1 srcCHA N], ker [RO E1 srcCHA dstCHA 1 or N], 
-             buf is a buffer for computer, need to be pre-allocated [RO E1 srcCHA], y [RO E1 dstCHA N]
-             for the sake of speed, no check is made in this function
-    */
-    template<typename T> EXPORTGTPLUS bool imageDomainUnwrapping2DT(const hoNDArray<T>& x, const hoNDArray<T>& ker, hoNDArray<T>& buf, hoNDArray<T>& y);
-
-    /**
     * @brief compute periodic boundary values for an array
              x : [N 1] the data point location, y[N M] data point values at x
              r : [N+2 M], the data point values with computed boundaries
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconUtil.hxx
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconUtil.hxx
@@ -1131,7 +1131,7 @@ kspacefilterRO(hoNDArray<T>& data, const
     try
     {
         GADGET_CHECK_RETURN_FALSE(data.get_size(0)==fRO.get_number_of_elements());
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fRO, data, data));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fRO, data));
     }
     catch(...)
     {
@@ -1149,7 +1149,7 @@ kspacefilterRO(const hoNDArray<T>& data,
     try
     {
         GADGET_CHECK_RETURN_FALSE(data.get_size(0)==fRO.get_number_of_elements());
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fRO, data, dataFiltered));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fRO, dataFiltered));
     }
     catch(...)
     {
@@ -1167,7 +1167,7 @@ kspacefilterROE1(const hoNDArray<T>& dat
     try
     {
         GADGET_CHECK_RETURN_FALSE(data.get_size(0)*data.get_size(1)==fROE1.get_number_of_elements());
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fROE1, data, dataFiltered));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fROE1, dataFiltered));
     }
     catch(...)
     {
@@ -1190,7 +1190,7 @@ kspacefilterROE1(const hoNDArray<T>& dat
         hoNDArray<T> fxy;
         compute2DFilterFromTwo1D(fRO, fE1, fxy);
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fxy, data, dataFiltered));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fxy, dataFiltered));
     }
     catch(...)
     {
@@ -1215,7 +1215,7 @@ kspacefilterE1(const hoNDArray<T>& data,
         hoNDArray<T> fxy;
         compute2DFilterFromTwo1D(fRO, fE1, fxy);
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fxy, data, dataFiltered));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fxy, dataFiltered));
     }
     catch(...)
     {
@@ -1314,7 +1314,7 @@ kspacefilterROE1E2(const hoNDArray<T>& d
     {
         if ( data.get_size(2)==1 && data.get_size(3)==1 )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fROE1E2, data, dataFiltered));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fROE1E2, dataFiltered));
         }
         else
         {
@@ -1335,7 +1335,7 @@ kspacefilterROE1E2(const hoNDArray<T>& d
 
             boost::shared_ptr< hoNDArray<T> > data_permuted = Gadgetron::permute(const_cast<hoNDArray<T>*>(&data), &order);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fROE1E2, data, dataFiltered));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fROE1E2, dataFiltered));
 
             order[0] = 0;
             order[1] = 1;
@@ -1470,7 +1470,7 @@ kspace3DfilterROE1E2(const hoNDArray<T>&
         GADGET_CHECK_RETURN_FALSE(data.get_size(1)==fROE1E2.get_size(1));
         GADGET_CHECK_RETURN_FALSE(data.get_size(2)==fROE1E2.get_size(2));
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(fROE1E2, data, dataFiltered));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, fROE1E2, dataFiltered));
     }
     catch(...)
     {
@@ -2007,9 +2007,18 @@ detectSampledRegion2D(const hoNDArray<T>
         if ( NDim > 2 )
         {
             size_t ii;
+            std::vector<size_t> dim;
             for ( ii=0; ii<NDim-2; ii++ )
             {
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(mag, magSum));
+                mag.get_dimensions(dim);
+
+                // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(mag, magSum));
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(mag, magSum, mag.get_number_of_dimensions() - 1));
+
+                std::vector<size_t> dimSum(dim.size()-1);
+                memcpy(&dimSum[0], &dim[0], sizeof(size_t)*dimSum.size());
+                magSum.reshape(dimSum);
+
                 mag = magSum;
             }
         }
@@ -2025,8 +2034,8 @@ detectSampledRegion2D(const hoNDArray<T>
 
         size_t ro, e1;
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver2ndDimension(mag, magSumE1));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(mag, magSumRO));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag, magSumE1, 1));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag, magSumRO, 0));
 
         for ( ro=0; ro<RO; ro++ )
         {
@@ -2080,10 +2089,20 @@ detectSampledRegion3D(const hoNDArray<T>
 
         if ( NDim > 5 )
         {
+            std::vector<size_t> dim;
+
             size_t ii;
             for ( ii=0; ii<NDim-5; ii++ )
             {
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(mag, magSum));
+                mag.get_dimensions(dim);
+
+                // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(mag, magSum));
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(mag, magSum, mag.get_number_of_dimensions() - 1));
+
+                std::vector<size_t> dimSum(dim.size() - 1);
+                memcpy(&dimSum[0], &dim[0], sizeof(size_t)*dimSum.size());
+                magSum.reshape(dimSum);
+
                 mag = magSum;
             }
         }
@@ -2103,17 +2122,18 @@ detectSampledRegion3D(const hoNDArray<T>
 
         size_t ro, e1, e2;
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver5thDimension(mag, magSum2));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(magSum2, magSum));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(magSum, magSum2));
-
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver2ndDimension(magSum2, magSumE1));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(magSum2, magSumRO));
-
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(mag, magSum2));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(magSum2, magSum));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver2ndDimension(magSum, magSum2));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(magSum2, magSumE2));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag, magSum2, 4));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum2, magSum, 3));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum, magSum2, 2));
+
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum2, magSumE1, 1));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum2, magSumRO, 0));
+
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag, magSum2, 3));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum2, magSum, 2));
+
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum, magSum2, 1));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(magSum2, magSumE2, 0));
 
         for ( ro=0; ro<RO; ro++ )
         {
@@ -2178,7 +2198,7 @@ averageKSpace4D(const hoNDArray<T>& data
 {
     try
     {
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(data, ave));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(data, ave, 3));
         Gadgetron::scal( (typename realType<T>::Type)(1.0/data.get_size(3)), ave);
     }
     catch(...)
@@ -2213,7 +2233,7 @@ averageKSpace4D(const hoNDArray<T>& data
 
         hoNDArray<T> data4D(RO, E1, CHA, N, const_cast<T*>(data.begin()));
         GADGET_CHECK_RETURN_FALSE(detectSampledTimesE1(data4D, sampledTimes));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(data, ave));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(data, ave, 3));
 
         boost::shared_ptr< std::vector<size_t> > dim = ave.get_dimensions();
 
@@ -2237,7 +2257,8 @@ averageKSpace4D(const hoNDArray<T>& data
             }
         }
 
-        GADGET_CHECK_RETURN_FALSE(multipleMultiply(sampledTimes2D, ave, ave));
+        // GADGET_CHECK_RETURN_FALSE(multipleMultiply(sampledTimes2D, ave, ave));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(multiply(ave, sampledTimes2D, ave));
     }
     catch(...)
     {
@@ -2254,7 +2275,7 @@ averageKSpace5D(const hoNDArray<T>& data
 {
     try
     {
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver5thDimension(data, ave));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(data, ave, 4));
         Gadgetron::scal( (typename realType<T>::Type)(1.0/data.get_size(4)), ave);
     }
     catch(...)
@@ -2290,7 +2311,7 @@ averageKSpace5D(const hoNDArray<T>& data
 
         hoNDArray<T> data5D(RO, E1, E2, CHA, N, const_cast<T*>(data.begin()));
         GADGET_CHECK_RETURN_FALSE(detectSampledTimesE1E2(data5D, sampledTimes));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver5thDimension(data, ave));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(data, ave, 4));
 
         hoNDArray<T> sampledTimes3D(RO, E1, E2);
         T* pTimes = sampledTimes3D.begin();
@@ -2309,7 +2330,8 @@ averageKSpace5D(const hoNDArray<T>& data
             }
         }
 
-        GADGET_CHECK_RETURN_FALSE(multipleMultiply(sampledTimes3D, ave, ave));
+        // GADGET_CHECK_RETURN_FALSE(multipleMultiply(sampledTimes3D, ave, ave));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(multiply(ave, sampledTimes3D, ave));
     }
     catch(...)
     {
@@ -2338,10 +2360,10 @@ detectSampledTimesE1(const hoNDArray<T>&
         Gadgetron::abs(data4D, mag);
 
         hoNDArray<typename realType<T>::Type> mag3D(RO, E1, 1, N);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(mag, mag3D));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag, mag3D, 2));
 
         hoNDArray<typename realType<T>::Type> mag2D(1, E1, 1, N);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(mag3D, mag2D));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag3D, mag2D, 0));
         typename realType<T>::Type* pMag2D = mag2D.begin();
 
         sampledTimes.resize(E1, 0);
@@ -2425,11 +2447,8 @@ detectSampledTimesE1E2(const hoNDArray<T
         hoNDArray<T> dataFirstChannel(RO, E1, E2, const_cast<T*>(data5D.begin()));
         Gadgetron::abs(dataFirstChannel, mag);
 
-        //hoNDArray<typename realType<T>::Type> mag4D(RO, E1, E2, 1, N);
-        //GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(mag, mag4D));
-
         hoNDArray<typename realType<T>::Type> mag3D(1, E1, E2);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(mag, mag3D));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(mag, mag3D, 0));
 
         typename realType<T>::Type* pMag3D = mag3D.begin();
 
@@ -4271,7 +4290,7 @@ zpadResize2DFilter(const hoNDArray<T>& d
         hoNDArray<T> kspace(data);
         Gadgetron::hoNDFFT<typename realType<T>::Type>::instance()->fft2c(data, kspace);
         GADGET_CHECK_RETURN_FALSE(this->zeropad2D(kspace, sizeX, sizeY, dataResized));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(filter2D, dataResized, dataResized));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(dataResized, filter2D, dataResized));
         Gadgetron::hoNDFFT<typename realType<T>::Type>::instance()->ifft2c(dataResized);
 
         typename realType<T>::Type scaling = (typename realType<T>::Type)(std::sqrt((double)sizeX*sizeY)/std::sqrt((double)RO*E1));
@@ -4320,7 +4339,7 @@ zpadResize3DFilter(const hoNDArray<T>& d
         hoNDArray<T> kspace(data);
         Gadgetron::hoNDFFT<typename realType<T>::Type>::instance()->fft3c(data, kspace);
         GADGET_CHECK_RETURN_FALSE(this->zeropad3D(kspace, sizeX, sizeY, sizeZ, dataResized));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(filter3D, dataResized, dataResized));
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(dataResized, filter3D, dataResized));
         Gadgetron::hoNDFFT<typename realType<T>::Type>::instance()->ifft3c(dataResized);
 
         typename realType<T>::Type scaling = (typename realType<T>::Type)(std::sqrt((double)sizeX*sizeY*sizeZ)/std::sqrt((double)RO*E1*E2));
@@ -4890,8 +4909,8 @@ coilMap2DNIH2Inner(const hoNDArray<T>& d
         size_t iter;
         long long cha;
 
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(data, D_sum));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver2ndDimension(D_sum, D_sum_1st_2nd));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(data, D_sum, 0));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D_sum, D_sum_1st_2nd, 1));
         Gadgetron::norm2(D_sum_1st_2nd, v);
         Gadgetron::scal( (value_type)1.0/v, D_sum_1st_2nd);
 
@@ -4909,35 +4928,35 @@ coilMap2DNIH2Inner(const hoNDArray<T>& d
 
             Gadgetron::conjugate(R, R);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(R, data, coilMap));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, R, coilMap));
 
             Gadgetron::conv2(coilMap, ker, coilMapConv);
 
             Gadgetron::multiplyConj(coilMapConv, coilMapConv, D);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(D, R));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D, R, 2));
 
             Gadgetron::sqrt(R, R);
 
             Gadgetron::addEpsilon(R);
             Gadgetron::inv(R, R);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(R, coilMapConv, coilMap));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(coilMapConv, R, coilMap));
 
             Gadgetron::multiplyConj(data, coilMap, D);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(D, R));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D, R, 2));
 
             //if ( iter < iterNum - 1 )
             //{
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(R, coilMap, D));
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(coilMap, R, D));
             //}
             //else
             //{
             //    D = coilMap;
             //}
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(D, D_sum));
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver2ndDimension(D_sum, D_sum_1st_2nd));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D, D_sum, 0));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D_sum, D_sum_1st_2nd, 1));
 
             Gadgetron::norm2(D_sum_1st_2nd, v);
             Gadgetron::scal( (value_type)1.0/v, D_sum_1st_2nd);
@@ -4955,7 +4974,7 @@ coilMap2DNIH2Inner(const hoNDArray<T>& d
 
             Gadgetron::multiply(R, imT, R);
             Gadgetron::conjugate(imT, imT);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(imT, coilMap, coilMap));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(coilMap, imT, coilMap));
 
             Gadgetron::subtract(prevR, R, diffR);
             Gadgetron::norm2(diffR, vDiffR);
@@ -5096,7 +5115,7 @@ coilMap3DNIH2Inner(const hoNDArray<T>& d
         size_t iter, cha;
 
         hoNDArray<T> dataByCha(RO*E1*E2, CHA, const_cast<T*>(data.begin()));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(data, D_sum));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(data, D_sum, 0));
         Gadgetron::norm2(D_sum, v);
         Gadgetron::scal( (value_type)1.0/v, D_sum);
 
@@ -5112,27 +5131,27 @@ coilMap3DNIH2Inner(const hoNDArray<T>& d
         {
             Gadgetron::conjugate(R, R);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(R, data, coilMap));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(data, R, coilMap));
 
             Gadgetron::conv2(coilMap, ker, coilMapConv);
 
             Gadgetron::multiplyConj(coilMapConv, coilMapConv, D);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(D, R));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D, R, 3));
 
             Gadgetron::sqrt(R, R);
 
             Gadgetron::addEpsilon(R);
             Gadgetron::inv(R, R);
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(R, coilMapConv, coilMap));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(coilMapConv, R, coilMap));
 
             Gadgetron::multiplyConj(data, coilMap, D);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(D, R));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(D, R, 3));
 
             //if ( iter < iterNum - 1 )
             //{
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(R, coilMap, D));
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiply(coilMap, R, D));
             //}
             //else
             //{
@@ -5140,7 +5159,7 @@ coilMap3DNIH2Inner(const hoNDArray<T>& d
             //}
 
             hoNDArray<T> DByCha(RO*E1*E2, CHA, D.begin());
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver1stDimension(DByCha, D_sum));
+            GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(DByCha, D_sum, 0));
 
             Gadgetron::norm2(D_sum, v);
             Gadgetron::scal( (value_type)1.0/v, D_sum);
@@ -5158,7 +5177,7 @@ coilMap3DNIH2Inner(const hoNDArray<T>& d
 
             Gadgetron::multiply(R, imT, R);
             Gadgetron::conjugate(imT, imT);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(imT, coilMap, coilMap));
+            Gadgetron::multiply(coilMap, imT, coilMap);
         }
     }
     catch(...)
@@ -5280,15 +5299,31 @@ sumOfSquare(const hoNDArray<T>& data, ho
 
         if ( NDim == 3 )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(tmp, sos));
+            // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(tmp, sos));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(tmp, sos, 2));
+
+            std::vector<size_t> dim(2);
+            dim[0] = sos.get_size(0);
+            dim[1] = sos.get_size(1);
+
+            sos.reshape(dim);
         }
         else if ( NDim == 4 )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(tmp, sos));
+            // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverSecondLastDimension(tmp, sos));
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(tmp, sos, 2));
+
+            std::vector<size_t> dim(3);
+            dim[0] = sos.get_size(0);
+            dim[1] = sos.get_size(1);
+            dim[2] = sos.get_size(3);
+
+            sos.reshape(dim);
         }
         else
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(tmp, sos));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(tmp, sos, 2));
         }
 
         Gadgetron::sqrt(sos, sos);
@@ -5377,7 +5412,7 @@ coilCombine(const hoNDArray<T>& data, co
                 hoNDArray<T> coilMapCurr(RO, E1, CHA, const_cast<T*>(coilMap.begin())+offsetCoilMap);
 
                 Gadgetron::multiplyConj(dataCurr, coilMapCurr, dataTmp);
-                Gadgetron::sumOver3rdDimension(dataTmp, combinedCurr);
+                GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(dataTmp, combinedCurr, 2));
 
                 memcpy(combined.begin()+offsetCombined, combinedCurr.begin(), sizeof(T)*RO*E1);
             }
@@ -5422,7 +5457,7 @@ coilCombine(const hoNDArray<T>& data, co
                 hoNDArray<T> coilMapCurr(RO, E1, CHA, N, const_cast<T*>(coilMap.begin())+offsetCoilMap);
 
                 Gadgetron::multiplyConj(dataCurr, coilMapCurr, dataTmp);
-                Gadgetron::sumOver3rdDimension(dataTmp, combinedCurr);
+                GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(dataTmp, combinedCurr, 2));
 
                 memcpy(combined.begin()+offsetCombined, combinedCurr.begin(), sizeof(T)*RO*E1*N);
             }
@@ -5487,7 +5522,7 @@ coilCombine3D(const hoNDArray<T>& data,
                 Gadgetron::multiplyConj(dataCurr, coilMap, dataTmp);
 
                 hoNDArray<T> dataCombinedCurr(&dimCombinedCurr, const_cast<T*>(combined.begin()+nn*NCombined));
-                Gadgetron::sumOver4thDimension(dataTmp, dataCombinedCurr);
+                Gadgetron::sum_over_dimension(dataTmp, dataCombinedCurr, 3);
             }
         }
     }
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorkFlowCartesian.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorkFlowCartesian.h
@@ -206,7 +206,17 @@ preProcessing()
         // combine the segment dimension
         if ( SEG_.second > 1 )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(*data_, dataCurr_));
+            // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(*data_, dataCurr_));
+
+            std::vector<size_t> dim, dimCurr;
+            data_->get_dimensions(dim);
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(*data_, dataCurr_, data_->get_number_of_dimensions()-1));
+
+            dimCurr.resize(dim.size() - 1);
+            memcpy(&dimCurr[0], &dim[0], sizeof(size_t)*dimCurr.size());
+            dataCurr_.reshape(dimCurr);
+
             *data_ = dataCurr_;
             SEG_.second = 1;
 
@@ -223,7 +233,17 @@ preProcessing()
 
         if ( ref_!=NULL && SEG_ref_.second>1 )
         {
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(*ref_, refCurr_));
+            // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(*ref_, refCurr_));
+
+            std::vector<size_t> dim, dimCurr;
+            ref_->get_dimensions(dim);
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(*ref_, refCurr_, ref_->get_number_of_dimensions() - 1));
+
+            dimCurr.resize(dim.size() - 1);
+            memcpy(&dimCurr[0], &dim[0], sizeof(size_t)*dimCurr.size());
+            refCurr_.reshape(dimCurr);
+
             *ref_ = refCurr_;
             SEG_ref_.second = 1;
             if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(*data_, debugFolder_+"incomingRef_SEGCombined"); }
@@ -660,17 +680,48 @@ postProcessing(hoNDArray<T>& res, bool p
         if ( E2_.second > 1 )
         {
             if ( performTiming_ ) { gt_timer1_.start("postProcessing - permute res array ... "); }
-            // boost::shared_ptr< hoNDArray<T> > data_permuted = Gadgetron::permute(const_cast<hoNDArray<T>*>(&dataCurr_), &order);
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To3rdDimension(res, dataCurr_));
+
+            // permute E2 dimension from [RO E1 CHA SLC E2 ...] to [RO E1 E2 CHA SLC ...]
+
+            std::vector<size_t> dim_order(5);
+            dim_order[0] = 0;
+            dim_order[1] = 1;
+            dim_order[2] = 4;
+            dim_order[3] = 2;
+            dim_order[4] = 3;
+
+            std::vector<size_t> dim, dimPermuted;
+            res.get_dimensions(dim);
+            dimPermuted = dim;
+            dimPermuted[2] = dim[4];
+            dimPermuted[3] = dim[2];
+            dimPermuted[4] = dim[3];
+
+            dataCurr_.create(dimPermuted);
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&res, &dataCurr_, &dim_order));
 
             if ( has_gfactor )
             {
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To3rdDimension(gfactor_, gfactorCurr_));
+                gfactor_.get_dimensions(dim);
+                dimPermuted = dim;
+                dimPermuted[2] = dim[4];
+                dimPermuted[3] = dim[2];
+                dimPermuted[4] = dim[3];
+
+                gfactorCurr_.create(dimPermuted);
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&gfactor_, &gfactorCurr_, &dim_order));
             }
 
             if ( has_wrap_around )
             {
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To3rdDimension(wrap_around_map_, wrap_around_mapCurr_));
+                wrap_around_map_.get_dimensions(dim);
+                dimPermuted = dim;
+                dimPermuted[2] = dim[4];
+                dimPermuted[3] = dim[2];
+                dimPermuted[4] = dim[3];
+
+                wrap_around_mapCurr_.create(dimPermuted);
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&wrap_around_map_, &wrap_around_mapCurr_, &dim_order));
             }
 
             if ( performTiming_ ) { gt_timer1_.stop(); }
@@ -769,16 +820,24 @@ postProcessing(hoNDArray<T>& res, bool p
 
             GADGET_CHECK_RETURN_FALSE(convertToReconSpace3D(dataCurr_, res, inKSpace));
 
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To5thDimension(res, dataCurr_));
-
-            //order[0] = 0;
-            //order[1] = 1;
-            //order[2] = 3;
-            //order[3] = 4;
-            //order[4] = 2;
+            {
+                std::vector<size_t> dim_order(5);
+                dim_order[0] = 0;
+                dim_order[1] = 1;
+                dim_order[2] = 3;
+                dim_order[3] = 4;
+                dim_order[4] = 2;
+
+                std::vector<size_t> dim, dimPermuted;
+                res.get_dimensions(dim);
+                dimPermuted = dim;
+                dimPermuted[2] = dim[3];
+                dimPermuted[3] = dim[4];
+                dimPermuted[4] = dim[2];
 
-            //data_permuted = Gadgetron::permute(const_cast<hoNDArray<T>*>(&res), &order);
-            //res = *data_permuted;
+                dataCurr_.create(dimPermuted);
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&res, &dataCurr_, &dim_order));
+            }
 
             res.reshape(dataCurr_.get_dimensions());
             memcpy(res.begin(), dataCurr_.begin(), res.get_number_of_bytes());
@@ -788,7 +847,23 @@ postProcessing(hoNDArray<T>& res, bool p
             if ( has_gfactor )
             {
                 GADGET_CHECK_RETURN_FALSE(convertToReconSpace3D(gfactorCurr_, gfactor_, false));
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To5thDimension(gfactor_, gfactorCurr_));
+
+                std::vector<size_t> dim_order(5);
+                dim_order[0] = 0;
+                dim_order[1] = 1;
+                dim_order[2] = 3;
+                dim_order[3] = 4;
+                dim_order[4] = 2;
+
+                std::vector<size_t> dim, dimPermuted;
+                gfactor_.get_dimensions(dim);
+                dimPermuted = dim;
+                dimPermuted[2] = dim[3];
+                dimPermuted[3] = dim[4];
+                dimPermuted[4] = dim[2];
+
+                gfactorCurr_.create(dimPermuted);
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&gfactor_, &gfactorCurr_, &dim_order));
 
                 gfactor_.reshape(gfactorCurr_.get_dimensions());
                 memcpy(gfactor_.begin(), gfactorCurr_.begin(), gfactor_.get_number_of_bytes());
@@ -799,7 +874,23 @@ postProcessing(hoNDArray<T>& res, bool p
             if ( has_wrap_around )
             {
                 GADGET_CHECK_RETURN_FALSE(convertToReconSpace3D(wrap_around_mapCurr_, wrap_around_map_, false));
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To5thDimension(wrap_around_map_, wrap_around_mapCurr_));
+
+                std::vector<size_t> dim_order(5);
+                dim_order[0] = 0;
+                dim_order[1] = 1;
+                dim_order[2] = 3;
+                dim_order[3] = 4;
+                dim_order[4] = 2;
+
+                std::vector<size_t> dim, dimPermuted;
+                wrap_around_map_.get_dimensions(dim);
+                dimPermuted = dim;
+                dimPermuted[2] = dim[3];
+                dimPermuted[3] = dim[4];
+                dimPermuted[4] = dim[2];
+
+                wrap_around_mapCurr_.create(dimPermuted);
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&wrap_around_map_, &wrap_around_mapCurr_, &dim_order));
 
                 wrap_around_map_.reshape(wrap_around_mapCurr_.get_dimensions());
                 memcpy(wrap_around_map_.begin(), wrap_around_mapCurr_.begin(), wrap_around_map_.get_number_of_bytes());
@@ -1625,6 +1716,8 @@ copyGFactor(size_t dim5, size_t dim6, si
             size_t gfactor_N = workOrder_->gfactor_.get_size(2);
             size_t gfactor_S = workOrder_->gfactor_.get_size(3);
 
+            if (!debugFolder_.empty()) { gt_exporter_.exportArrayComplex(workOrder_->gfactor_, debugFolder_ + "workOrder_gfactor_afterunwrapping"); }
+
             std::vector<size_t> indRes(10);
             indRes[0] = 0;
             indRes[1] = 0;
@@ -1688,6 +1781,8 @@ copyGFactor(size_t dim5, size_t dim6, si
                     }
                 }
             }
+
+            if (!debugFolder_.empty()) { gt_exporter_.exportArrayComplex(gfactor_, debugFolder_ + "gfactor_after_copyGFactor"); }
         }
     }
     catch(...)
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker2DT.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker2DT.h
@@ -384,10 +384,15 @@ bool gtPlusReconWorker2DT<T>::prepRef(gt
 
             hoNDArray<typename realType<T>::Type> refMag(refRecon.get_dimensions()), refMagSum;
             GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::abs(refRecon, refMag));
-            GADGET_CHECK_RETURN_FALSE(sumOverLastDimension(refMag, refMagSum));
+            /*GADGET_CHECK_RETURN_FALSE(sumOverLastDimension(refMag, refMagSum));
             GADGET_CHECK_RETURN_FALSE(sumOverLastDimension(refMagSum, refMag));
-            GADGET_CHECK_RETURN_FALSE(sumOverLastDimension(refMag, refMagSum));
+            GADGET_CHECK_RETURN_FALSE(sumOverLastDimension(refMag, refMagSum));*/
 
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(sum_over_dimension(refMag, refMagSum, refMag.get_number_of_dimensions()-1));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(sum_over_dimension(refMagSum, refMag, refMagSum.get_number_of_dimensions() - 2));
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(sum_over_dimension(refMag, refMagSum, refMag.get_number_of_dimensions() - 3));
+
+            refMagSum.squeeze();
             GADGET_CHECK_RETURN_FALSE(gtPlusISMRMRDReconUtil<float>().detectSampledRegionE1(refMagSum, startE1_, endE1_));
 
             std::vector<size_t> crop_offset(5);
@@ -1069,6 +1074,11 @@ performCalib(gtPlusReconWorkOrder2DT<T>*
                     if ( workOrder2DT->gfactor_needed_ ) { GADGET_CHECK_RETURN_FALSE(repmatLastDimension(workOrder2DT->gfactor_, usedS)); }
                     if ( workOrder2DT->wrap_around_map_needed_ ) { GADGET_CHECK_RETURN_FALSE(repmatLastDimension(workOrder2DT->wrap_around_map_, usedS)); }
                 }
+
+                if (!debugFolder_.empty())
+                {
+                    gt_exporter_.exportArrayComplex(workOrder2DT->gfactor_, debugFolder_ + "gfactor_after_calib");
+                }
             }
             else
             {
@@ -1093,6 +1103,11 @@ performCalib(gtPlusReconWorkOrder2DT<T>*
                 #ifdef USE_OMP
                     omp_set_nested(0);
                 #endif // USE_OMP
+
+                if (!debugFolder_.empty())
+                {
+                    gt_exporter_.exportArrayComplex(workOrder2DT->gfactor_, debugFolder_ + "gfactor_after_calib");
+                }
             }
         }
     }
@@ -1178,7 +1193,12 @@ bool gtPlusReconWorker2DT<T>::unmixCoeff
 
         hoNDArray<T> conjUnmixCoeff(unmixCoeff);
         GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiplyConj(unmixCoeff, conjUnmixCoeff, conjUnmixCoeff));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(conjUnmixCoeff, gFactor));
+        // GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(conjUnmixCoeff, gFactor));
+
+        hoNDArray<T> gFactorBuf(RO, E1, 1, gFactor.begin());
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(conjUnmixCoeff, gFactorBuf, 2));
+
+        // memcpy(gFactor.begin(), gFactorBuf.begin(), sizeof(T)*RO*E1);
         Gadgetron::sqrt(gFactor, gFactor);
     }
     catch(...)
@@ -1267,15 +1287,14 @@ bool gtPlusReconWorker2DT<T>::applyImage
 
         if ( num <= 8 )
         {
-            if ( performTiming_ ) { gt_timer3_.start("applyImageDomainKernelImage - multipleMultiply - sumOverSecondLastDimension ... "); }
+            if ( performTiming_ ) { gt_timer3_.start("apply image domain kernel image ... "); }
             for ( n=0; n<(int)num; n++ )
             {
                 hoNDArray<T> buf3D(&dim3D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*srcCHA));
-                hoNDArray<T> bufIm3D(&dimIm3D, complexIm.begin()+n*RO*E1*dstCHA);
+                hoNDArray<T> bufIm3D(RO, E1, 1, dstCHA, complexIm.begin() + n*RO*E1*dstCHA);
 
-                // Gadgetron::multipleMultiply(buf3D, kerIm, kerImBuffer);
                 Gadgetron::multiply(kerIm, buf3D, kerImBuffer);
-                Gadgetron::sumOverSecondLastDimension(kerImBuffer, bufIm3D);
+                Gadgetron::sum_over_dimension(kerImBuffer, bufIm3D, 2);
             }
             if ( performTiming_ ) { gt_timer3_.stop(); }
         }
@@ -1291,11 +1310,10 @@ bool gtPlusReconWorker2DT<T>::applyImage
                 for ( n=0; n<(int)num; n++ )
                 {
                     buf3D.create(&dim3D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*srcCHA));
-                    bufIm3D.create(&dimIm3D, complexIm.begin()+n*RO*E1*dstCHA);
+                    bufIm3D.create(RO, E1, 1, dstCHA, complexIm.begin() + n*RO*E1*dstCHA);
 
-                    // Gadgetron::multipleMultiply(buf3D, kerIm, buf4D);
                     Gadgetron::multiply(kerIm, buf3D, buf4D);
-                    Gadgetron::sumOverSecondLastDimension(buf4D, bufIm3D);
+                    Gadgetron::sum_over_dimension(buf4D, bufIm3D, 2);
                 }
             }
         }
@@ -1352,12 +1370,10 @@ bool gtPlusReconWorker2DT<T>::applyUnmix
         }
         Gadgetron::clear(&complexIm);
 
-        // hoNDArray<T> tmp(aliasedIm);
         buffer2DT_unwrapping_ = aliasedIm;
 
-        // GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(unmixCoeff, aliasedIm, buffer2DT_unwrapping_));
         Gadgetron::multiply(aliasedIm, unmixCoeff, buffer2DT_unwrapping_);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver3rdDimension(buffer2DT_unwrapping_, complexIm));
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(buffer2DT_unwrapping_, complexIm, 2));
     }
     catch(...)
     {
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DT.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DT.h
@@ -1169,8 +1169,6 @@ bool gtPlusReconWorker3DT<T>::unmixCoeff
 
         unmixCoeff.create(RO, E1, E2, srcCHA);
         Gadgetron::clear(&unmixCoeff);
-        gFactor.create(RO, E1, E2);
-        Gadgetron::clear(&gFactor);
 
         int src;
 
@@ -1206,7 +1204,12 @@ bool gtPlusReconWorker3DT<T>::unmixCoeff
 
         hoNDArray<T> conjUnmixCoeff(unmixCoeff);
         GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::multiplyConj(unmixCoeff, conjUnmixCoeff, conjUnmixCoeff));
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOverLastDimension(conjUnmixCoeff, gFactor));
+
+        gFactor.create(RO, E1, E2);
+        Gadgetron::clear(&gFactor);
+
+        hoNDArray<T> gFactorBuf(RO, E1, E2, 1, gFactor.begin());
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::sum_over_dimension(conjUnmixCoeff, gFactorBuf, 3));
         Gadgetron::sqrt(gFactor, gFactor);
     }
     catch(...)
@@ -1300,109 +1303,26 @@ bool gtPlusReconWorker3DT<T>::applyImage
 
         int n;
 
-        //if ( num <= 16 )
-        //{
-            //#ifdef USE_OMP
-            //    omp_set_nested(1);
-            //#endif // USE_OMP
-
-            //// #pragma omp parallel default(none) private(n) shared(kerIm, num, dim4D, aliasedIm, RO, E1, E2, srcCHA, dimIm4D, dstCHA, complexIm) if ( num >= 16 )
-            //for ( n=0; n<(int)num; n++ )
-            //{
-            //    hoNDArray<T> buf4D(&dim4D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*E2*srcCHA));
-            //    // hoNDArray<T> bufIm4D(&dimIm4D, complexIm.begin()+n*RO*E1*E2*dstCHA);
-
-            //    int dCha;
-
-            //    #pragma omp parallel default(none) private(dCha) shared(n, buf4D, kerIm, kerImBuffer, num, dim4D, aliasedIm, RO, E1, E2, srcCHA, dimIm4D, dstCHA, complexIm)
-            //    {
-            //        // hoNDArrayMemoryManaged<T> unwarpped4D(RO, E1, E1, srcCHA, gtPlus_mem_manager_);
-
-            //        #pragma omp for
-            //        for ( dCha=0; dCha<(int)dstCHA; dCha++ )
-            //        {
-            //            hoNDArray<T> kerIm4D(RO, E1, E2, srcCHA, const_cast<T*>(kerIm.begin()+dCha*RO*E1*E2*srcCHA));
-            //            hoNDArray<T> complexIm3D(RO, E1, E2, complexIm.begin()+n*RO*E1*E2*dstCHA+dCha*RO*E1*E2);
-            //            hoNDArray<T> unwrapped4D(RO, E1, E2, srcCHA, kerImBuffer.begin()+dCha*RO*E1*E2*srcCHA);
-            //            Gadgetron::multipleMultiply(buf4D, kerIm4D, unwrapped4D);
-            //            Gadgetron::sumOverLastDimension(unwrapped4D, complexIm3D);
-            //        }
-            //    }
-            //}
-
-            #ifdef USE_OMP
-                omp_set_nested(1);
-            #endif // USE_OMP
-
-            //for ( n=0; n<(int)num; n++ )
-            //{
-            //    hoNDArray<T> buf4D(&dim4D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*E2*srcCHA));
-
-            //    int dCha;
-
-            //    //hoNDArrayMemoryManaged<T> unwarpped4D(RO, E1, E2, srcCHA, gtPlus_mem_manager_);
-
-            //    hoNDArray<T> unwrapped4D(RO, E1, E2, srcCHA, kerImBuffer.begin());
-
-            //    for ( dCha=0; dCha<(int)dstCHA; dCha++ )
-            //    {
-            //        hoNDArray<T> kerIm4D(RO, E1, E2, srcCHA, const_cast<T*>(kerIm.begin()+dCha*RO*E1*E2*srcCHA));
-            //        hoNDArray<T> complexIm3D(RO, E1, E2, complexIm.begin()+n*RO*E1*E2*dstCHA+dCha*RO*E1*E2);
-            //        Gadgetron::multipleMultiply(buf4D, kerIm4D, unwrapped4D);
-            //        Gadgetron::sumOverLastDimension(unwrapped4D, complexIm3D);
-            //    }
-            //}
+        #pragma omp parallel default(none) private(n) shared(num, dim4D, aliasedIm, RO, E1, E2, srcCHA, dstCHA, kerIm, complexIm) num_threads( (int)((num<16) ? num : 16) )
+        {
+            hoNDArrayMemoryManaged<T> unwrapped4D(RO, E1, E2, srcCHA, gtPlus_mem_manager_);
 
-            #pragma omp parallel default(none) private(n) shared(num, dim4D, aliasedIm, RO, E1, E2, srcCHA, dstCHA, kerIm, complexIm) num_threads( (int)((num<16) ? num : 16) )
+            #pragma omp for
+            for ( n=0; n<(int)num; n++ )
             {
-                hoNDArrayMemoryManaged<T> unwrapped4D(RO, E1, E2, srcCHA, gtPlus_mem_manager_);
+                hoNDArray<T> buf4D(&dim4D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*E2*srcCHA));
 
-                #pragma omp for
-                for ( n=0; n<(int)num; n++ )
-                {
-                    hoNDArray<T> buf4D(&dim4D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*E2*srcCHA));
-
-                    int dCha;
-
-                    //hoNDArrayMemoryManaged<T> unwarpped4D(RO, E1, E2, srcCHA, gtPlus_mem_manager_);
-
-                    //hoNDArray<T> unwrapped4D(RO, E1, E2, srcCHA, kerImBuffer.begin());
+                int dCha;
 
-                    for ( dCha=0; dCha<(int)dstCHA; dCha++ )
-                    {
-                        hoNDArray<T> kerIm4D(RO, E1, E2, srcCHA, const_cast<T*>(kerIm.begin()+dCha*RO*E1*E2*srcCHA));
-                        hoNDArray<T> complexIm3D(RO, E1, E2, complexIm.begin()+n*RO*E1*E2*dstCHA+dCha*RO*E1*E2);
-                        // Gadgetron::multipleMultiply(buf4D, kerIm4D, unwrapped4D);
-                        Gadgetron::multiply(kerIm4D, buf4D, unwrapped4D);
-                        Gadgetron::sumOverLastDimension(unwrapped4D, complexIm3D);
-                    }
+                for ( dCha=0; dCha<(int)dstCHA; dCha++ )
+                {
+                    hoNDArray<T> kerIm4D(RO, E1, E2, srcCHA, const_cast<T*>(kerIm.begin()+dCha*RO*E1*E2*srcCHA));
+                    hoNDArray<T> complexIm3D(RO, E1, E2, 1, complexIm.begin()+n*RO*E1*E2*dstCHA+dCha*RO*E1*E2);
+                    Gadgetron::multiply(kerIm4D, buf4D, unwrapped4D);
+                    Gadgetron::sum_over_dimension(unwrapped4D, complexIm3D, 3);
                 }
             }
-
-        #ifdef USE_OMP
-            omp_set_nested(0);
-        #endif
-
-        //}
-        //else
-        //{
-        //    #pragma omp parallel default(none) private(n) shared(kerIm, num, dim4D, aliasedIm, RO, E1, E2, srcCHA, dimIm4D, dstCHA, complexIm) 
-        //    {
-        //        hoNDArray<T> buf4D;
-        //        hoNDArray<T> bufIm4D;
-        //        hoNDArray<T> buf5D(kerIm.get_dimensions());
-
-        //        #pragma omp for
-        //        for ( n=0; n<(int)num; n++ )
-        //        {
-        //            buf4D.create(&dim4D, const_cast<T*>(aliasedIm.begin()+n*RO*E1*E2*srcCHA));
-        //            bufIm4D.create(&dimIm4D, complexIm.begin()+n*RO*E1*E2*dstCHA);
-
-        //            Gadgetron::multipleMultiply(buf4D, kerIm, buf5D);
-        //            Gadgetron::sumOverSecondLastDimension(buf5D, bufIm4D);
-        //        }
-        //    }
-        //}
+        }
     }
     catch(...)
     {
@@ -1458,14 +1378,10 @@ bool gtPlusReconWorker3DT<T>::applyUnmix
         }
         Gadgetron::clear(&complexIm);
 
-        // hoNDArray<T> tmp(aliasedIm);
-        // buffer3DT_unwrapping_ = aliasedIm;
-
         hoNDArrayMemoryManaged<T> buffer3DT(aliasedIm.get_dimensions(), gtPlus_mem_manager_);
 
-        // GADGET_CHECK_RETURN_FALSE(Gadgetron::multipleMultiply(unmixCoeff, aliasedIm, buffer3DT));
-        Gadgetron::multipleMultiply(aliasedIm, unmixCoeff, buffer3DT);
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::sumOver4thDimension(buffer3DT, complexIm));
+        Gadgetron::multiply(aliasedIm, unmixCoeff, buffer3DT);
+        GADGET_CATCH_THROW(Gadgetron::sum_over_dimension(buffer3DT, complexIm, 3));
     }
     catch(...)
     {
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DTGRAPPA.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DTGRAPPA.h
@@ -427,7 +427,14 @@ performUnwrapping(gtPlusReconWorkOrder3D
                     if ( performTiming_ ) { gt_timer3_.stop(); }
 
                     if ( performTiming_ ) { gt_timer3_.start("permuteROTo3rdDimensionFor3DRecon for aliased images ... "); }
-                    GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo3rdDimensionFor3DRecon(aliasedIm, aliasedImPermuted));
+
+                    std::vector<size_t> dim_order(3);
+                    dim_order[0] = 1;
+                    dim_order[1] = 2;
+                    dim_order[2] = 0;
+
+                    GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&aliasedIm, &aliasedImPermuted, &dim_order));
+
                     if ( performTiming_ ) { gt_timer3_.stop(); }
 
                     // unwrapped images
@@ -512,8 +519,35 @@ performUnwrapping(gtPlusReconWorkOrder3D
                         ro += jobN;
                     }
 
-                    if ( performTiming_ ) { gt_timer3_.start("permuteROTo3rdDimensionFor3DRecon for unwrapped images ... "); }
-                    GADGET_CHECK_RETURN_FALSE(Gadgetron::permute3rdDimensionTo1stDimension(unwrappedImPermuted, workOrder3DT->fullkspace_));
+                    if ( performTiming_ ) { gt_timer3_.start("permute RO to 1st dimension for unwrapped images ... "); }
+                    {
+                        size_t N3D = RO*E1*E2;
+                        size_t Num = dstCHA*N;
+
+                        T* pX = unwrappedImPermuted.begin();
+                        T* pR = workOrder3DT->fullkspace_.begin();
+
+                        long long n, e2;
+                        for (n = 0; n < (long long)Num; n++)
+                        {
+                            T* pXn = pX + n*N3D;
+                            T* pRn = pR + n*N3D;
+
+#pragma omp parallel for default(none) private(e2) shared(RO, E1, E2, pXn, pRn)
+                            for (e2 = 0; e2 < (long long)E2; e2++)
+                            {
+                                for (size_t e1 = 0; e1 < E1; e1++)
+                                {
+                                    size_t indXn = e1 + e2*E1;
+                                    size_t indRn = e1*RO + e2*RO*E1;
+                                    for (size_t ro = 0; ro < RO; ro++)
+                                    {
+                                        pRn[ro + indRn] = pXn[ro*E1*E2 + indXn];
+                                    }
+                                }
+                            }
+                        }
+                    }
                     if ( performTiming_ ) { gt_timer3_.stop(); }
                 }
                 else
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DTL1SPIRITNCG.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DTL1SPIRITNCG.h
@@ -203,21 +203,50 @@ performUnwarppingImpl(gtPlusReconWorkOrd
         hoNDArrayMemoryManaged<T> kspaceIfftROPermuted(E1, E2, srcCHA, RO, gtPlus_mem_manager_);
 
         if ( performTiming_ ) { gt_timer3_.start("permtue RO to 4th dimension ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo4thDimensionFor3DRecon(kspaceIfftRO, kspaceIfftROPermuted));
+
+        std::vector<size_t> dim_order(4);
+        dim_order[0] = 1;
+        dim_order[1] = 2;
+        dim_order[2] = 3;
+        dim_order[3] = 0;
+
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&kspaceIfftRO, &kspaceIfftROPermuted, &dim_order));
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
         if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(kspaceIfftROPermuted, debugFolder_+"kspaceIfftROPermuted"); }
 
         // permute kernel
         hoNDArray<T> kerPermuted(E1, E2, srcCHA, dstCHA, RO);
         if ( performTiming_ ) { gt_timer3_.start("permute kernel RO to 5th dimension ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To5thDimension( adj_forward_G_I, kerPermuted));
+
+        {
+            std::vector<size_t> dim_order(5);
+            dim_order[0] = 0;
+            dim_order[1] = 1;
+            dim_order[2] = 3;
+            dim_order[3] = 4;
+            dim_order[4] = 2;
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&adj_forward_G_I, &kerPermuted, &dim_order));
+        }
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
 
         // permute coil map
         hoNDArray<T> coilMapN(RO, E1, E2, dstCHA, workOrder3DT->coilMap_->begin()+n*RO*E1*E2*dstCHA);
         hoNDArray<T> coilMapPermuted(E1, E2, dstCHA, RO);
         if ( performTiming_ ) { gt_timer3_.start("permtue coil map RO to 4th dimension ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo4thDimensionFor3DRecon(coilMapN, coilMapPermuted));
+
+        {
+            std::vector<size_t> dim_order(4);
+            dim_order[0] = 1;
+            dim_order[1] = 2;
+            dim_order[2] = 3;
+            dim_order[3] = 0;
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&coilMapN, &coilMapPermuted, &dim_order));
+        }
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
         if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(coilMapPermuted, debugFolder_+"coilMapPermuted"); }
 
@@ -226,7 +255,17 @@ performUnwarppingImpl(gtPlusReconWorkOrd
 
         // permute the unwrapped kspace
         if ( performTiming_ ) { gt_timer3_.start("permtue RO to 1st dimension ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo1stDimensionFor3DRecon(resPermuted, kspaceIfftRO));
+
+        {
+            std::vector<size_t> dim_order(4);
+            dim_order[0] = 3;
+            dim_order[1] = 0;
+            dim_order[2] = 1;
+            dim_order[3] = 2;
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&resPermuted, &kspaceIfftRO, &dim_order));
+        }
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
 
         // perform fft along the first dimension
--- gadgetron-3.1.1.orig/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DTSPIRIT.h
+++ gadgetron-3.1.1/toolboxes/gtplus/workflow/gtPlusISMRMRDReconWorker3DTSPIRIT.h
@@ -383,7 +383,15 @@ performUnwrapping(gtPlusReconWorkOrder3D
             // hoNDArrayMemoryManaged<T> kspaceIfftROPermuted(E1, E2, srcCHA, RO, N, gtPlus_mem_manager_);
             hoNDArray<T> kspaceIfftROPermuted(E1, E2, srcCHA, RO, N);
             if ( performTiming_ ) { gt_timer3_.start("permute kspace RO to 4th dimension ... "); }
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo4thDimensionFor3DRecon(kspaceIfftRO, kspaceIfftROPermuted));
+
+            std::vector<size_t> dim_order(4);
+            dim_order[0] = 1;
+            dim_order[1] = 2;
+            dim_order[2] = 3;
+            dim_order[3] = 0;
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&kspaceIfftRO, &kspaceIfftROPermuted, &dim_order));
+
             if ( performTiming_ ) { gt_timer3_.stop(); }
             if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(kspaceIfftROPermuted, debugFolder_+"kspaceIfftROPermuted"); }
 
@@ -415,8 +423,16 @@ performUnwrapping(gtPlusReconWorkOrder3D
                 if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(*workOrder3DT->kernelIm_, debugFolder_+"kernelImBeforePermuted"); }
 
                 if ( performTiming_ ) { gt_timer3_.start("permute kernel RO to 5th dimension ... "); }
-                // GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo5thDimensionFor3DRecon( *workOrder3DT->kernelIm_, kerPermuted));
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteE2To5thDimension( *workOrder3DT->kernelIm_, kerPermuted));
+
+                std::vector<size_t> dim_order(5);
+                dim_order[0] = 0;
+                dim_order[1] = 1;
+                dim_order[2] = 3;
+                dim_order[3] = 4;
+                dim_order[4] = 2;
+
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(workOrder3DT->kernelIm_.get(), &kerPermuted, &dim_order));
+
                 if ( performTiming_ ) { gt_timer3_.stop(); }
 
                 if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(kerPermuted, debugFolder_+"kerPermuted"); }
@@ -442,9 +458,23 @@ performUnwrapping(gtPlusReconWorkOrder3D
             if ( workOrder3DT->coilMap_->get_number_of_elements() > 0 )
             {
                 if ( performTiming_ ) { gt_timer3_.start("permute coil map RO to 4th dimension ... "); }
-                GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo4thDimensionFor3DRecon(*workOrder3DT->coilMap_, *coilMapPermuted));
+
+                coilMapPermuted->create(workOrder3DT->coilMap_->get_size(1), 
+                                        workOrder3DT->coilMap_->get_size(2), 
+                                        workOrder3DT->coilMap_->get_size(3), 
+                                        workOrder3DT->coilMap_->get_size(0), 
+                                        workOrder3DT->coilMap_->get_size(4) );
+
+                std::vector<size_t> dim_order(4);
+                dim_order[0] = 1;
+                dim_order[1] = 2;
+                dim_order[2] = 3;
+                dim_order[3] = 0;
+
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(workOrder3DT->coilMap_.get(), coilMapPermuted.get(), &dim_order));
+
                 if ( performTiming_ ) { gt_timer3_.stop(); }
-                if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(kspaceIfftROPermuted, debugFolder_+"coilMapPermuted"); }
+                if (!debugFolder_.empty()) { gt_exporter_.exportArrayComplex(*coilMapPermuted, debugFolder_ + "coilMapPermuted"); }
 
                 workOrder3DTJobSplit.coilMap_ = coilMapPermuted;
             }
@@ -641,7 +671,17 @@ performUnwrapping(gtPlusReconWorkOrder3D
 
             // permute the unwrapped kspace
             if ( performTiming_ ) { gt_timer3_.start("permtue RO to 1st dimension ... "); }
-            GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo1stDimensionFor3DRecon(workOrder3DTJobSplit.fullkspace_, kspaceIfftRO));
+
+            {
+                std::vector<size_t> dim_order(4);
+                dim_order[0] = 3;
+                dim_order[1] = 0;
+                dim_order[2] = 1;
+                dim_order[3] = 2;
+
+                GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&workOrder3DTJobSplit.fullkspace_, &kspaceIfftRO, &dim_order));
+            }
+
             if ( performTiming_ ) { gt_timer3_.stop(); }
 
             if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(kspaceIfftRO, debugFolder_+"res_fullkspace_ROinIm"); }
@@ -887,7 +927,15 @@ performUnwarppingImpl(gtPlusReconWorkOrd
         hoNDArrayMemoryManaged<T> kspaceIfftROPermuted(E1, E2, srcCHA, RO, gtPlus_mem_manager_);
 
         if ( performTiming_ ) { gt_timer3_.start("permtue RO to 4th dimension ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo4thDimensionFor3DRecon(kspaceIfftRO, kspaceIfftROPermuted));
+
+        std::vector<size_t> dim_order(4);
+        dim_order[0] = 1;
+        dim_order[1] = 2;
+        dim_order[2] = 3;
+        dim_order[3] = 0;
+
+        GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&kspaceIfftRO, &kspaceIfftROPermuted, &dim_order));
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
         if ( !debugFolder_.empty() ) { gt_exporter_.exportArrayComplex(kspaceIfftROPermuted, debugFolder_+"kspaceIfftROPermuted"); }
 
@@ -981,7 +1029,17 @@ performUnwarppingImpl(gtPlusReconWorkOrd
 
         // permute the unwrapped kspace
         if ( performTiming_ ) { gt_timer3_.start("permtue RO to 1st dimension ... "); }
-        GADGET_CHECK_RETURN_FALSE(Gadgetron::permuteROTo1stDimensionFor3DRecon(resDecoupled, kspaceIfftRO));
+
+        {
+            std::vector<size_t> dim_order(4);
+            dim_order[0] = 3;
+            dim_order[1] = 0;
+            dim_order[2] = 1;
+            dim_order[3] = 2;
+
+            GADGET_CHECK_EXCEPTION_RETURN_FALSE(Gadgetron::permute(&resDecoupled, &kspaceIfftRO, &dim_order));
+        }
+
         if ( performTiming_ ) { gt_timer3_.stop(); }
 
         // perform fft along the first dimension
--- gadgetron-3.1.1.orig/toolboxes/mri/hyper/CMRTOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/hyper/CMRTOperator.h
@@ -130,9 +130,7 @@ public:
 
 	}
 
-	virtual boost::shared_ptr< linearOperator< cuNDArray<complext<REAL> > > > clone(){
-		return linearOperator<cuNDArray<complext<REAL> > >::clone(this);
-	}
+
 protected:
 
 	cuNFFTOperator<REAL,2> E_; //cuNFFTOperator reconstructing the 2d projections
--- gadgetron-3.1.1.orig/toolboxes/mri/hyper/CSIOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/hyper/CSIOperator.h
@@ -29,9 +29,7 @@ public:
 
 	T get_echotime(){ return dte_;}
 	T get_pointtime(){return dtt_;}
-	virtual boost::shared_ptr<linearOperator<cuNDArray<complext<T>>>> clone(){
-		return linearOperator<cuNDArray<complext<T>>>::clone(this);
-	}
+
 protected:
 	boost::shared_ptr<linearOperator<cuNDArray<complext<T>>>> senseOp;
 	T dte_; //Time between echoes
--- gadgetron-3.1.1.orig/toolboxes/mri/hyper/CSfreqOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/hyper/CSfreqOperator.h
@@ -43,9 +43,6 @@ public:
 	}
 
 
-	virtual boost::shared_ptr<linearOperator<cuNDArray<complext<float>>>> clone(){
-		return linearOperator<cuNDArray<complext<float>>>::clone(this);
-	}
 	thrust::device_vector<float> freqs;
 	float dtt,dte;
 };
--- gadgetron-3.1.1.orig/toolboxes/mri/pmri/gpu/cuCartesianSenseOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/pmri/gpu/cuCartesianSenseOperator.h
@@ -29,10 +29,6 @@ namespace Gadgetron{
       }
     }
     
-    virtual boost::shared_ptr< linearOperator<  cuNDArray< complext<REAL>  > > > clone(){
-      return linearOperator< cuNDArray<complext<REAL> > >::clone(this);
-    }
-    
   protected:
     boost::shared_ptr< cuNDArray<unsigned int> > idx_;
   };
--- gadgetron-3.1.1.orig/toolboxes/mri/pmri/gpu/cuNonCartesianKtSenseOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/pmri/gpu/cuNonCartesianKtSenseOperator.h
@@ -23,8 +23,5 @@ namespace Gadgetron{
     virtual void mult_M( cuNDArray< complext<REAL> >* in, cuNDArray< complext<REAL> >* out, bool accumulate = false );
     virtual void mult_MH( cuNDArray< complext<REAL> >* in, cuNDArray< complext<REAL> >* out, bool accumulate = false );
     
-    virtual boost::shared_ptr< linearOperator<cuNDArray< complext<REAL>  > > > clone(){
-      return linearOperator< cuNDArray<complext<REAL> > >::clone(this);
-    }  
   };
 }
--- gadgetron-3.1.1.orig/toolboxes/mri/pmri/gpu/cuNonCartesianSenseOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/pmri/gpu/cuNonCartesianSenseOperator.h
@@ -35,9 +35,7 @@ namespace Gadgetron{
     virtual void preprocess( cuNDArray<_reald> *trajectory );
     virtual void set_dcw( boost::shared_ptr< cuNDArray<REAL> > dcw );
 
-    virtual boost::shared_ptr< linearOperator<cuNDArray< complext<REAL>  > > > clone(){
-      return linearOperator< cuNDArray<complext<REAL> > >::clone(this);
-    }
+
   
   protected:
     boost::shared_ptr< cuNFFT_plan<REAL, D, ATOMICS> > plan_;
--- gadgetron-3.1.1.orig/toolboxes/mri/pmri/gpu/cuSpiritOperator.h
+++ gadgetron-3.1.1/toolboxes/mri/pmri/gpu/cuSpiritOperator.h
@@ -132,9 +132,7 @@ const unsigned int num_coils_squared = k
 		*out -= *in;
 	}
 
-	virtual boost::shared_ptr< linearOperator< cuNDArray< complext<REAL> > > > clone() {
-		return linearOperator< cuNDArray< complext<REAL> > >::clone(this);
-	}
+
 
 protected:
 	boost::shared_ptr< cuNDArray< complext<REAL> > > kernels_;
--- gadgetron-3.1.1.orig/toolboxes/nfft/gpu/cuNFFTOperator.h
+++ gadgetron-3.1.1/toolboxes/nfft/gpu/cuNFFTOperator.h
@@ -28,9 +28,6 @@ namespace Gadgetron{
     virtual void mult_MH( cuNDArray< complext<REAL> > *in, cuNDArray< complext<REAL> > *out, bool accumulate = false );
     virtual void mult_MH_M( cuNDArray< complext<REAL> > *in, cuNDArray< complext<REAL> > *out, bool accumulate = false );
 
-    virtual boost::shared_ptr< linearOperator< cuNDArray< complext<REAL>  > > > clone(){
-      return linearOperator< cuNDArray<complext<REAL> > >::clone(this);
-    }
 
   protected:
     boost::shared_ptr< cuNFFT_plan<REAL, D,ATOMICS> > plan_;
--- gadgetron-3.1.1.orig/toolboxes/operators/cpu/hoPartialDerivativeOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/cpu/hoPartialDerivativeOperator.h
@@ -103,8 +103,5 @@ namespace Gadgetron{
               }
           }
 
-          virtual boost::shared_ptr< linearOperator< hoNDArray<T> > > clone() {
-              return linearOperator< hoNDArray<T> >::clone(this);
-          }    
     };
 }
--- gadgetron-3.1.1.orig/toolboxes/operators/diagonalOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/diagonalOperator.h
@@ -67,10 +67,6 @@ namespace Gadgetron {
       }
     }
   
-    virtual boost::shared_ptr< linearOperator<ARRAY_TYPE> > clone() {
-      return linearOperator<ARRAY_TYPE>::clone(this);
-    }
-  
   protected:
     boost::shared_ptr<ARRAY_TYPE> diagonal_;
     boost::shared_ptr<ARRAY_TYPE> diagonal_conj_;
--- gadgetron-3.1.1.orig/toolboxes/operators/diagonalSumOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/diagonalSumOperator.h
@@ -87,9 +87,6 @@ namespace Gadgetron {
         *out += tmp;
       }
     }
-    
-    virtual boost::shared_ptr< linearOperator<ARRAY_TYPE> > clone() {
-      return linearOperator<ARRAY_TYPE>::clone(this);
-    }
+
   };
 }
--- gadgetron-3.1.1.orig/toolboxes/operators/encodingOperatorContainer.h
+++ gadgetron-3.1.1/toolboxes/operators/encodingOperatorContainer.h
@@ -223,11 +223,6 @@ namespace Gadgetron{
       }
     }
 
-    virtual boost::shared_ptr< linearOperator< ARRAY_TYPE> > clone()
-    {
-      return linearOperator< ARRAY_TYPE >::clone(this);
-    }
-  
   protected:
     std::vector< boost::shared_ptr< linearOperator<ARRAY_TYPE> > > operators_;
     std::vector<size_t> offsets_;
--- gadgetron-3.1.1.orig/toolboxes/operators/gpu/cuConvolutionOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/gpu/cuConvolutionOperator.h
@@ -24,9 +24,5 @@ namespace Gadgetron{
     virtual void operator_fft( bool forwards_transform, cuNDArray< complext<REAL> > *image );
     virtual void origin_mirror( cuNDArray< complext<REAL> > *in, cuNDArray< complext<REAL> > *out );
     
-    virtual boost::shared_ptr< linearOperator<cuNDArray< complext<REAL> > > > clone()
-    {
-      return linearOperator< cuNDArray< complext<REAL> > >::clone(this);
-    }
   };
 }
--- gadgetron-3.1.1.orig/toolboxes/operators/gpu/cuImageOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/gpu/cuImageOperator.h
@@ -22,9 +22,6 @@ namespace Gadgetron{
 
     typedef typename imageOperator< cuNDArray<typename realType<T>::Type>, cuNDArray<T> >::REAL REAL;
 
-    virtual boost::shared_ptr< linearOperator< cuNDArray<T> > > clone() {
-      return linearOperator< cuNDArray<T> >::clone(this);
-    }
 
   protected:
 
--- gadgetron-3.1.1.orig/toolboxes/operators/gpu/cuLaplaceOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/gpu/cuLaplaceOperator.h
@@ -17,10 +17,7 @@ namespace Gadgetron{
     cuLaplaceOperator() : laplaceOperator< D, cuNDArray<T> >() {}
     virtual ~cuLaplaceOperator() {}
     
-    virtual boost::shared_ptr< linearOperator< cuNDArray<T> > > clone(){
-      return linearOperator<cuNDArray<T> >::clone(this);
-    }
-    
+
   protected:
     virtual void compute_laplace( cuNDArray<T> *in, cuNDArray<T> *out, bool accumulate );    
   };
--- gadgetron-3.1.1.orig/toolboxes/operators/gpu/cuPartialDerivativeOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/gpu/cuPartialDerivativeOperator.h
@@ -30,8 +30,6 @@ namespace Gadgetron{
                                                           typename int64d<D>::Type adjoint_stride, 
                                                           cuNDArray<T> *in, cuNDArray<T> *out, bool accumulate );  
     
-    virtual boost::shared_ptr< linearOperator< cuNDArray<T> > > clone() {
-      return linearOperator< cuNDArray<T> >::clone(this);
-    }    
+
   };
 }
--- gadgetron-3.1.1.orig/toolboxes/operators/gpu/cuPartialDerivativeOperator2.h
+++ gadgetron-3.1.1/toolboxes/operators/gpu/cuPartialDerivativeOperator2.h
@@ -22,10 +22,6 @@ public:
   virtual void mult_MH(cuNDArray<T> *in, cuNDArray<T> *out, bool accumulate = false );
 
   virtual void mult_MH_M( cuNDArray<T> *in, cuNDArray<T>*out, bool accumulate = false );
-  virtual boost::shared_ptr< linearOperator<  cuNDArray< T > > > clone()
-    {
-      return linearOperator< cuNDArray<T> >::clone(this);
-    }
 
 };
 }
--- gadgetron-3.1.1.orig/toolboxes/operators/gpu/hoCuPartialDerivativeOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/gpu/hoCuPartialDerivativeOperator.h
@@ -23,10 +23,6 @@ namespace Gadgetron{
       linearOperator<hoCuNDArray<T> >(),dev(dimension),hoDev(dimension), _dimension(dimension){ }
 
     virtual ~hoCuPartialDerivativeOperator() {}
-      
-    virtual boost::shared_ptr< linearOperator<hoCuNDArray<T> > > clone() {
-      return linearOperator<hoCuNDArray<T> >::clone(this);
-    }
 
     //TODO: Generalize to work if we can fit just the 1 single dimension on the gpu
     virtual void mult_M(hoCuNDArray<T>* in, hoCuNDArray<T>* out, bool accumulate)
--- gadgetron-3.1.1.orig/toolboxes/operators/identityOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/identityOperator.h
@@ -46,10 +46,6 @@ namespace Gadgetron{
     {
       return mult_M(in, out, accumulate);
     }
-    
-    virtual boost::shared_ptr< linearOperator< ARRAY_TYPE > > clone()
-    {
-      return linearOperator<ARRAY_TYPE>::clone(this);
-    }
+
   };
 }
--- gadgetron-3.1.1.orig/toolboxes/operators/linearOperator.h
+++ gadgetron-3.1.1/toolboxes/operators/linearOperator.h
@@ -87,21 +87,6 @@ namespace Gadgetron{
       mult_MH( &tmp, out, accumulate );
     }
 
-    virtual boost::shared_ptr< linearOperator<ARRAY_TYPE > > clone() = 0;
-
-  protected:
-
-    // The template below is useful for implementing the pure virtual 'clone' method
-    //
-
-    template <class T> static
-      boost::shared_ptr<T> clone( T *orig )
-      {
-	boost::shared_ptr<T> copy( new T() );
-	*copy = *orig;
-	return copy;
-      }
-
   protected:
     std::vector<size_t> codomain_dims_;
   };
--- gadgetron-3.1.1.orig/toolboxes/python_math/CMakeLists.txt
+++ gadgetron-3.1.1/toolboxes/python_math/CMakeLists.txt
@@ -19,22 +19,14 @@ target_link_libraries(gadgetron_toolbox_
 			${ACE_LIBRARIES}
 			gadgetron_toolbox_log)
 
-add_executable(gadgetron_test_python_math
-  test_python_math.cpp)
-
-target_link_libraries(gadgetron_test_python_math
-  gadgetron_toolbox_python_math
-  gadgetron_toolbox_cpucore
-  ${PYTHON_LIBRARIES}
-  ${Boost_LIBRARIES}
-  gadgetron_toolbox_log)
-
 set_target_properties(gadgetron_toolbox_python_math  PROPERTIES VERSION ${GADGETRON_VERSION_STRING} SOVERSION ${GADGETRON_SOVERSION})
+set_target_properties (gadgetron_toolbox_python_math PROPERTIES COMPILE_DEFINITIONS "__BUILD_GADGETRON_TOOLBOX_PYTHON_MATH__")
 
 install(TARGETS gadgetron_toolbox_python_math DESTINATION lib COMPONENT main)
-install(TARGETS gadgetron_test_python_math DESTINATION bin COMPONENT main)
 
 install(FILES 
   PythonMath.h
   python_math_export.h
   DESTINATION include COMPONENT main)
+
+add_subdirectory(example)
--- gadgetron-3.1.1.orig/toolboxes/python_math/PythonMath.cpp
+++ gadgetron-3.1.1/toolboxes/python_math/PythonMath.cpp
@@ -1,172 +1,83 @@
 #include "PythonMath.h"
-#include "log.h"
-
-#include <stdexcept>
 
 #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
-#include <boost/python.hpp>
-//#include <boost/numpy.hpp>
 #include <numpy/numpyconfig.h>
 #include <numpy/arrayobject.h>
 
-namespace bp = boost::python;
 
 namespace Gadgetron
 {
 
-  template <typename T> void bp_object_to_hondarray(bp::object& obj, hoNDArray< T >* arr)
-  {
-    if (!arr) {
-      throw std::runtime_error("bp_object_to_hondarray received null pointer array");
-    }
-
-    if (sizeof(T) != PyArray_ITEMSIZE((PyArrayObject*)obj.ptr())) {
-      GERROR("sizeof(T): %d, ITEMSIZE: %d\n", sizeof(T), PyArray_ITEMSIZE((PyArrayObject*)obj.ptr()));
-      throw std::runtime_error("bp_object_to_hondarray: python object and array data type sizes do not match");
-    }
-
-    size_t ndim = PyArray_NDIM((PyArrayObject*)obj.ptr());
-    std::vector<size_t> dims(ndim);
-    for (size_t i = 0; i < ndim; i++) {
-      dims[ndim-i-1] = PyArray_DIM((PyArrayObject*)obj.ptr(),i);
-    }
-
-    if (!arr->dimensions_equal(&dims)) {
-      arr->create(dims);
-    }
+static bool initialized = false;
 
-    memcpy(arr->get_data_ptr(), PyArray_DATA((PyArrayObject*)obj.ptr()), sizeof(T)*arr->get_number_of_elements());
-  }
-
-  template <typename T> int get_numpy_type();
-  template <> int get_numpy_type< std::complex<float> >() {return NPY_COMPLEX64;}
-  template <> int get_numpy_type< std::complex<double> >() {return NPY_COMPLEX128;}
-  template <> int get_numpy_type< float >() {return NPY_FLOAT32;}
-  template <> int get_numpy_type< unsigned int >() {return NPY_UINT32;}
-
-  template <typename T> bp::object hondarray_to_bp_object(hoNDArray< T >* arr)
-  {
-    if (!arr) {
-      throw std::runtime_error("hondarray_to_bp_object: null pointer passed for arr");
-    }
-
-    size_t ndim = arr->get_number_of_dimensions();
-    std::vector<int> dims2(ndim);
-    for (unsigned int i = 0; i < ndim; i++) dims2[ndim-i-1] = static_cast<int>(arr->get_size(i));
-    bp::object obj(bp::handle<>(PyArray_FromDims(dims2.size(), &dims2[0], get_numpy_type<T>())));
-    
-    if (sizeof(T) != PyArray_ITEMSIZE((PyArrayObject*)obj.ptr())) {
-      GERROR("sizeof(T): %d, ITEMSIZE: %d\n", sizeof(T), PyArray_ITEMSIZE((PyArrayObject*)obj.ptr()));
-      throw std::runtime_error("hondarray_to_bp_object: python object and array data type sizes do not match");
+void initialize_python_math(void)
+{
+    if (!initialized) {
+        Py_Initialize();
+        _import_array();    // import NumPy
+
+        PyEval_InitThreads();
+
+        //Swap out and return current thread state and release the GIL
+        //Must be done, otherwise subsequent calls to PyGILState_Ensure()
+        //will not be guaranteed to acquire lock
+        PyThreadState* tstate = PyEval_SaveThread();
+        if (!tstate) {
+            GDEBUG("Error occurred returning lock to Python\n");
+        }
+        initialized = true;
     }
+}
 
-    //Copy data
-    memcpy(PyArray_DATA((PyArrayObject*)obj.ptr()), arr->get_data_ptr(), arr->get_number_of_elements()*sizeof(std::complex<float>));
-
-    return obj;
-  }
-  
-  PythonMath* PythonMath::instance_ = 0;
-
-  PythonMath* PythonMath::instance()
-  {
-    if (!instance_)
-      {
-	instance_ = new PythonMath();
-      }
-    return instance_;
-  }
-
-  PythonMath::PythonMath()
-  {
-    Py_Initialize();
-    //boost::numpy::initialize();
-    _import_array();
-    
-    PyEval_InitThreads();
-    
-    //Swap out and return current thread state and release the GIL
-    //Must be done, otherwise subsequent calls to PyGILState_Ensure() will not be guaranteed to acuire lock
-    PyThreadState* tstate = PyEval_SaveThread();
-    if (!tstate) {
-      GDEBUG("Error occurred returning lock to Python\n");
+/// Adapted from http://stackoverflow.com/a/6576177/1689220
+std::string pyerr_to_string(void)
+{
+    PyObject *exc, *val, *tb;
+    bp::object formatted_list, formatted;
+    PyErr_Fetch(&exc, &val, &tb);
+    // wrap exception, value, traceback with bp::handle for auto memory management
+    bp::handle<> hexc(exc), hval(bp::allow_null(val)), htb(bp::allow_null(tb));
+    // import "traceback" module
+    bp::object traceback(bp::import("traceback"));
+    if (!tb) {
+        bp::object format_exception_only(traceback.attr("format_exception_only"));
+        formatted_list = format_exception_only(hexc, hval);
+    } else {
+        bp::object format_exception(traceback.attr("format_exception"));
+        formatted_list = format_exception(hexc, hval, htb);
     }
+    formatted = bp::str("\n").join(formatted_list);
+    return bp::extract<std::string>(formatted);
+}
 
-  }
+/// Wraps PyArray_NDIM
+int NumPyArray_NDIM(PyObject* obj)
+{
+    return PyArray_NDIM((PyArrayObject*)obj);
+}
 
-  void PythonMath::calculate_grappa_unmixing(hoNDArray< std::complex<float> >* source_data, unsigned int acc_factor, hoNDArray< std::complex<float> >* unmix_out,
-					    unsigned int* kernel_size, hoNDArray< unsigned int >* data_mask, hoNDArray< std::complex<float> >* csm,
-					    float regularization_factor, hoNDArray< std::complex<float> >* target_data, 
-					    hoNDArray< float >* gmap_out)
-  {
-    GDEBUG("Called calculate grappa unmixing.\n");
-    
-    if (!source_data) {
-      throw std::runtime_error("Source data is NULL");
-    }
+/// Wraps PyArray_DIM
+npy_intp NumPyArray_DIM(PyObject* obj, int i)
+{
+    return PyArray_DIM((PyArrayObject*)obj, i);
+}
 
-    if (source_data->get_number_of_dimensions() != 3) {
-      throw std::runtime_error("source_data input array has wrong number of dimensions");
-    }
+/// Wraps PyArray_DATA
+void* NumPyArray_DATA(PyObject* obj)
+{
+    return PyArray_DATA((PyArrayObject*)obj);
+}
 
-    PyGILState_STATE gstate;
-    gstate = PyGILState_Ensure();
+/// Wraps PyArray_ITEMSIZE
+int NumPyArray_ITEMSIZE(PyObject* obj)
+{
+    return PyArray_ITEMSIZE((PyArrayObject*)obj);
+}
 
-    try {
-      bp::object mod = bp::import("ismrmrdtools.grappa"); 
-      bp::object fcn = mod.attr("calculate_grappa_unmixing");
-      bp::object source_data_obj = hondarray_to_bp_object(source_data);
-      bp::tuple kernel_size_obj;
-      bp::object data_mask_obj; //None
-      bp::object csm_obj; //None
-      bp::object target_data_obj; //None
-      
-      if (kernel_size) {
-	kernel_size_obj = bp::make_tuple(kernel_size[0],kernel_size[1]);
-      } else {
-	kernel_size_obj = bp::make_tuple(4,5);
-      }
-
-      if (data_mask) data_mask_obj = hondarray_to_bp_object(data_mask);
-      if (csm) csm_obj = hondarray_to_bp_object(csm);
-      if (target_data) target_data_obj = hondarray_to_bp_object(target_data);
-
-      bp::object result = fcn(source_data_obj,acc_factor,kernel_size_obj, data_mask_obj, csm_obj, regularization_factor, target_data_obj);
-
-      if (bp::len(result) != 2) {
-	throw std::runtime_error("Wrong number of results from python function");
-      }
-
-      bp::tuple result_ex = bp::extract<bp::tuple>(result);      
-      bp::object umx = bp::extract<bp::object>(result_ex[0]);
-      bp::object gmap = bp::extract<bp::object>(result_ex[1]);
-
-      if (PyArray_NDIM((PyArrayObject*)umx.ptr()) != 3) {
-	throw std::runtime_error("Returned unmixing coefficients have wrong number of dimensions");
-      } 
-
-      if (PyArray_NDIM((PyArrayObject*)gmap.ptr()) != 2) {
-	throw std::runtime_error("Returned gmap coefficients have wrong number of dimensions");
-      } 
-
-      bp_object_to_hondarray(umx, unmix_out);
-
-      if (gmap_out) {
-	bp_object_to_hondarray(gmap, gmap_out);
-      }
-
-      GDEBUG("Grappa unmixing calculation returned.\n");
-    } catch(bp::error_already_set const &) {
-      GERROR("Error calling python code in PythonMath\n");
-      PyErr_Print();
-      PyGILState_Release(gstate);
-    } catch (std::exception const & e) {
-      GERROR("Run time error in PythonMath\n");
-      PyGILState_Release(gstate);
-      throw;
-    }
-    PyGILState_Release(gstate);
+/// Wraps PyArray_SimpleNew
+PyObject* NumPyArray_SimpleNew(int nd, npy_intp* dims, int typenum)
+{
+    return PyArray_SimpleNew(nd, dims, typenum);
+}
 
-  }
-  
 }
--- gadgetron-3.1.1.orig/toolboxes/python_math/PythonMath.h
+++ gadgetron-3.1.1/toolboxes/python_math/PythonMath.h
@@ -2,35 +2,135 @@
 #define GADGETRON_PYTHON_MATH_H
 
 #include "python_math_export.h"
-#include <boost/thread/mutex.hpp>
-#include "hoNDArray.h"
+#include "converters.h"
+
+#include <boost/python.hpp>
+namespace bp = boost::python;
 
 namespace Gadgetron
 {
 
-  class EXPORTPYTHONMATH PythonMath
-  {
+/// Initializes Python and NumPy. Called by each PythonFunction constructor
+EXPORTPYTHONMATH void initialize_python_math(void);
+
+/// Extracts the exception/traceback to build and return a std::string
+EXPORTPYTHONMATH std::string pyerr_to_string(void);
+
+/// Utility class for RAII handling of the Python GIL. Usage:
+///
+///    GILLock lg;  // at the top of a block
+///
+class GILLock
+{
+public:
+    GILLock() { gstate_ = PyGILState_Ensure(); }
+    ~GILLock() { PyGILState_Release(gstate_); }
+private:
+    // noncopyable
+    GILLock(const GILLock&);
+    GILLock& operator=(const GILLock&);
 
-  public:
-    static PythonMath* instance();
+    PyGILState_STATE gstate_;
+};
 
-    /**
-       Wrapper for ismrmrdtools.grappa.calculate_grappa_unmixing(source_data, acc_factor, kernel_size=(4,5), data_mask=None, csm=None, regularization_factor=0.001, target_data=None):
-     */
-    void calculate_grappa_unmixing(hoNDArray< std::complex<float> >* source_data, unsigned int acc_factor, hoNDArray< std::complex<float> >* unmix_out,
-				  unsigned int* kernel_size = 0, hoNDArray< unsigned int >* data_mask = 0, hoNDArray< std::complex<float> >* csm = 0,
-				  float regularization_factor = 0.001, hoNDArray< std::complex<float> >* target_data = 0, 
-				  hoNDArray< float >* gmap_out = 0);
-
-  protected:
-    ///Protected constructor. 
-    PythonMath();
-
-    static PythonMath* instance_;
-    boost::mutex mtx_;
-  };
+/// Base class for templated PythonFunction class. Do not use directly.
+class PythonFunctionBase
+{
+protected:
+    PythonFunctionBase(const std::string& module, const std::string& funcname)
+    {
+        initialize_python_math(); // ensure Python and NumPy are initialized
+        GILLock lg; // Lock the GIL, releasing at the end of constructor
+        try {
+            // import the module and load the function
+            bp::object mod(bp::import(module.c_str()));
+            fn_ = mod.attr(funcname.c_str());
+        } catch (const bp::error_already_set&) {
+            throw std::runtime_error(pyerr_to_string());
+        }
+    }
+
+    bp::object fn_;
+};
+
+/// PythonFunction for multiple return types (std::tuple)
+template <typename... ReturnTypes>
+class PythonFunction : public PythonFunctionBase
+{
+public:
+    typedef std::tuple<ReturnTypes...> TupleType;
 
+    PythonFunction(const std::string& module, const std::string& funcname)
+      : PythonFunctionBase(module, funcname)
+    {
+        // register the tuple return type converter
+        register_converter<TupleType>();
+    }
+
+    template <typename... TS>
+    TupleType operator()(const TS&... args)
+    {
+        // register type converter for each parameter type
+        register_converter<TS...>();
+        GILLock lg; // lock GIL and release at function exit
+        try {
+            bp::object res = fn_(args...);
+            return bp::extract<TupleType>(res);
+        } catch (bp::error_already_set const &) {
+            throw std::runtime_error(pyerr_to_string());
+        }
+    }
+};
+
+/// PythonFunction for a single return type
+template <typename RetType>
+class PythonFunction<RetType> : public PythonFunctionBase
+{
+public:
+    PythonFunction(const std::string& module, const std::string& funcname)
+      : PythonFunctionBase(module, funcname)
+    {
+        // register the return type converter
+        register_converter<RetType>();
+    }
+
+    template <typename... TS>
+    RetType operator()(const TS&... args)
+    {
+        // register type converter for each parameter type
+        register_converter<TS...>();
+        GILLock lg; // lock GIL and release at function exit
+        try {
+            bp::object res = fn_(args...);
+            return bp::extract<RetType>(res);
+        } catch (bp::error_already_set const &) {
+            throw std::runtime_error(pyerr_to_string());
+        }
+    }
+};
+
+/// PythonFunction returning nothing
+template <>
+class PythonFunction<>  : public PythonFunctionBase
+{
+public:
+    PythonFunction(const std::string& module, const std::string& funcname)
+      : PythonFunctionBase(module, funcname) {}
+
+    template <typename... TS>
+    void operator()(const TS&... args)
+    {
+        // register type converter for each parameter type
+        register_converter<TS...>();
+        GILLock lg; // lock GIL and release at function exit
+        try {
+            bp::object res = fn_(args...);
+        } catch (bp::error_already_set const &) {
+            throw std::runtime_error(pyerr_to_string());
+        }
+    }
+};
 
 }
 
-#endif
+#endif // GADGETRON_PYTHON_MATH_H
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/converters.h
@@ -0,0 +1,29 @@
+#ifndef GADGETRON_PYTHON_MATH_CONVERSIONS_H
+#define GADGETRON_PYTHON_MATH_CONVERSIONS_H
+
+namespace Gadgetron {
+
+/// Interface for registering C++ <-> NumPy type converters.
+/// A static function on the `python_converter` struct allows
+/// for partial template specialization.
+template <typename T>
+struct python_converter {
+    static void create() { }
+};
+
+/// Convenience wrapper for `python_converter<TS...>::create()`
+template <typename ...TS>
+void register_converter(void) {
+    // Parameter packs can only be expanded in specific semantic situations.
+    // This creates a fake array to expand and create converters for each
+    // variadic type.
+    using expander = int[];
+    (void) expander {0, (python_converter<TS>::create(), 0)...};
+}
+
+}
+
+#include "tuple_converter.h"
+#include "hoNDArray_converter.h"
+
+#endif // GADGETRON_PYTHON_MATH_CONVERSIONS_H
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/example/CMakeLists.txt
@@ -0,0 +1,9 @@
+include_directories(${CMAKE_SOURCE_DIR}/toolboxes/python_math)
+
+add_executable(gadgetron_test_python_math test_python_math.cpp)
+target_link_libraries(gadgetron_test_python_math gadgetron_toolbox_python_math)
+
+add_executable(python_math_demo demo.cpp)
+target_link_libraries(python_math_demo gadgetron_toolbox_python_math)
+
+install(TARGETS gadgetron_test_python_math DESTINATION bin COMPONENT main)
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/example/demo.cpp
@@ -0,0 +1,48 @@
+#include "PythonMath.h"
+
+using namespace Gadgetron;
+
+int main(int argc, char** argv)
+{
+    int a = -42;
+    float b = 3.141592;
+    std::string c("hello, world");
+    unsigned int d(117);
+    std::complex<double> e(2.12894, -1.103103);
+
+    std::vector<size_t> dims;
+    dims.push_back(4);
+    dims.push_back(4);
+    dims.push_back(4);
+    hoNDArray<std::complex<float> > arr(dims);
+
+    // Call a function with no return value (print all arguments)
+    PythonFunction<> foo("__builtin__", "print");
+    foo(a, b, c, d, e, arr);
+
+    // Call a function with a single return value
+    PythonFunction<float> atan2("math", "atan2");
+    int x = 7, y = 4;
+    float atan = atan2(x, y);
+    std::cout << atan << std::endl;
+
+    // Call a function that returns a tuple
+    PythonFunction<float,float> divmod("__builtin__", "divmod");
+    float w = 6.89;
+    float z = 4.12;
+    float fsum = 0, fdiff = 0;
+    std::tie(fsum, fdiff) = divmod(w, z);
+    std::cout << fsum << ", " << fdiff << std::endl;
+
+    // Call a function that expects an iterable argument (tuple)
+    PythonFunction<int> tuplen("__builtin__", "len");
+    int l = tuplen(std::make_tuple(-7, 0, 7));
+    std::cout << "tuple length: " << l << std::endl;
+
+    // Generate an hoNDArray of even #s using numpy
+    PythonFunction<hoNDArray<float>> arange("numpy", "arange");
+    hoNDArray<float> evens = arange(0, 100, 2, "f64");
+    std::cout << evens.get_number_of_elements() << std::endl;
+
+    return 0;
+}
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/example/test_python_math.cpp
@@ -0,0 +1,34 @@
+#include "log.h"
+#include "PythonMath.h"
+#include "hoNDArray_fileio.h"
+
+
+using namespace Gadgetron;
+
+int main(int argc, char** argv)
+{
+  GINFO("This is the PythonMath test application\n");
+
+  if (argc < 2) {
+    GERROR("You must supply an input file\n");
+    return -1;
+  }
+
+  boost::shared_ptr< hoNDArray< std::complex<float> > > source_data = read_nd_array< std::complex<float> >(argv[1]);
+
+  size_t coils = source_data->get_size(2);
+  size_t ny = source_data->get_size(1);
+  size_t nx = source_data->get_size(0);
+  GINFO("Array dimensions [%d, %d, %d]\n", nx, ny, coils);
+
+  hoNDArray< std::complex<float> > unmix;
+  hoNDArray<float> gmap;
+
+  PythonFunction<hoNDArray<std::complex<float> >, hoNDArray<float> > calculate_grappa_unmixing("ismrmrdtools.grappa", "calculate_grappa_unmixing");
+
+  std::tie(unmix, gmap) = calculate_grappa_unmixing(*source_data.get(), 3);
+
+  write_nd_array(&unmix, "unmix.cplx");
+
+  return 0;
+}
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/hoNDArray_converter.h
@@ -0,0 +1,114 @@
+#ifndef GADGETRON_PYTHON_MATH_HONDARRAY_CONVERTER_H
+#define GADGETRON_PYTHON_MATH_HONDARRAY_CONVERTER_H
+
+#include "numpy_wrappers.h"
+
+#include "hoNDArray.h"
+#include "log.h"
+
+#include <boost/python.hpp>
+namespace bp = boost::python;
+
+namespace Gadgetron {
+
+/// return the enumerated numpy type for a given C++ type
+template <typename T> int get_numpy_type();
+template <> inline int get_numpy_type< char >() { return NPY_INT8; }
+template <> inline int get_numpy_type< unsigned char >() { return NPY_UINT8; }
+template <> inline int get_numpy_type< short >() { return NPY_INT16; }
+template <> inline int get_numpy_type< unsigned short >() { return NPY_UINT16; }
+template <> inline int get_numpy_type< int >() { return NPY_INT32; }
+template <> inline int get_numpy_type< unsigned int >() { return NPY_UINT32; }
+template <> inline int get_numpy_type< long >() { return NPY_INT64; }
+template <> inline int get_numpy_type< unsigned long >() { return NPY_UINT64; }
+template <> inline int get_numpy_type< float >() { return NPY_FLOAT32; }
+template <> inline int get_numpy_type< double >() { return NPY_FLOAT64; }
+template <> inline int get_numpy_type< std::complex<float> >() { return NPY_COMPLEX64; }
+template <> inline int get_numpy_type< std::complex<double> >() { return NPY_COMPLEX128; }
+
+/// Used for making a NumPy array from and hoNDArray
+template <typename T>
+struct hoNDArray_to_numpy_array {
+    static PyObject* convert(const hoNDArray<T>& arr) {
+        size_t ndim = arr.get_number_of_dimensions();
+        std::vector<npy_intp> dims2(ndim);
+        for (size_t i = 0; i < ndim; i++) {
+            dims2[ndim-i-1] = static_cast<npy_intp>(arr.get_size(i));
+        }
+        PyObject *obj = NumPyArray_SimpleNew(dims2.size(), &dims2[0], get_numpy_type<T>());
+        if (sizeof(T) != NumPyArray_ITEMSIZE(obj)) {
+            GERROR("sizeof(T): %d, ITEMSIZE: %d\n", sizeof(T), NumPyArray_ITEMSIZE(obj));
+            throw std::runtime_error("hondarray_to_bp_object: "
+                    "python object and array data type sizes do not match");
+        }
+
+        // Copy data
+        memcpy(NumPyArray_DATA(obj), arr.get_data_ptr(),
+                arr.get_number_of_elements() * sizeof(T));
+
+        // increment the reference count so it exists after `return`
+        return bp::incref(obj);
+    }
+};
+
+/// Used for making an hoNDArray from a NumPy array
+template <typename T>
+struct hoNDArray_from_numpy_array {
+    hoNDArray_from_numpy_array() {
+        // actually register this converter with Boost
+        bp::converter::registry::push_back(
+                &convertible,
+                &construct,
+                bp::type_id<hoNDArray<T> >());
+    }
+
+    /// Returns NULL if the NumPy array is not convertible
+    static void* convertible(PyObject* obj) {
+        if (sizeof(T) != NumPyArray_ITEMSIZE(obj)) {
+            GERROR("sizeof(T): %d, ITEMSIZE: %d\n", sizeof(T), NumPyArray_ITEMSIZE(obj));
+            return NULL;
+        }
+        return obj;
+    }
+
+    /// Construct an hoNDArray in-place
+    static void construct(PyObject* obj, bp::converter::rvalue_from_python_stage1_data* data) {
+        void* storage = ((bp::converter::rvalue_from_python_storage<hoNDArray<T> >*)data)->storage.bytes;
+        size_t ndim = NumPyArray_NDIM(obj);
+        std::vector<size_t> dims(ndim);
+        for (size_t i = 0; i < ndim; i++) {
+            dims[ndim - i - 1] = NumPyArray_DIM(obj, i);
+        }
+
+        // Placement-new of hoNDArray in memory provided by Boost
+        hoNDArray<T>* arr = new (storage) hoNDArray<T>(dims);
+        memcpy(arr->get_data_ptr(), NumPyArray_DATA(obj),
+                sizeof(T) * arr->get_number_of_elements());
+        data->convertible = storage;
+    }
+};
+
+/// Create and register hoNDArray converter as necessary
+template <typename T> void create_hoNDArray_converter() {
+    bp::type_info info = bp::type_id<hoNDArray<T> >();
+    const bp::converter::registration* reg = bp::converter::registry::query(info);
+    // only register if not already registered!
+    if (nullptr == reg || nullptr == (*reg).m_to_python) {
+        bp::to_python_converter<hoNDArray<T>, hoNDArray_to_numpy_array<T> >();
+        hoNDArray_from_numpy_array<T>();
+    }
+}
+
+/// Partial specialization of `python_converter` for hoNDArray
+template <typename T>
+struct python_converter<hoNDArray<T> > {
+    static void create()
+    {
+        // register hoNDArray converter
+        create_hoNDArray_converter<T>();
+    }
+};
+
+}
+
+#endif // GADGETRON_PYTHON_MATH_HONDARRAY_CONVERTER_H
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/numpy_wrappers.h
@@ -0,0 +1,20 @@
+#ifndef GADGETRON_PYTHON_MATH_NUMPY_WRAPPERS_H
+#define GADGETRON_PYTHON_MATH_NUMPY_WRAPPERS_H
+
+#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
+#include "numpy/ndarraytypes.h"
+
+namespace Gadgetron {
+
+/// Wrappers for NumPy C-API functions. These functions must be used
+/// in the same C++ source file as the call to `import_array()`. In this
+/// case, that is PythonMath.cpp. The simplest solution is to lightly wrap the API.
+EXPORTPYTHONMATH int NumPyArray_NDIM(PyObject* obj);
+EXPORTPYTHONMATH npy_intp NumPyArray_DIM(PyObject* obj, int i);
+EXPORTPYTHONMATH void *NumPyArray_DATA(PyObject* obj);
+EXPORTPYTHONMATH int NumPyArray_ITEMSIZE(PyObject* obj);
+EXPORTPYTHONMATH PyObject *NumPyArray_SimpleNew(int nd, npy_intp* dims, int typenum);
+
+}
+
+#endif // GADGETRON_PYTHON_MATH_NUMPY_WRAPPERS_H
--- /dev/null
+++ gadgetron-3.1.1/toolboxes/python_math/tuple_converter.h
@@ -0,0 +1,120 @@
+// Source: https://gist.github.com/niwibe/3729459
+#ifndef GADGETRON_PYTHON_MATH_TUPLE_CONVERTER_H
+#define GADGETRON_PYTHON_MATH_TUPLE_CONVERTER_H
+
+#include <boost/python.hpp>
+namespace bp = boost::python;
+
+namespace Gadgetron {
+
+/// indices trick
+template<int ...> struct seq{};
+template<int N, int ...S> struct gens : gens<N-1, N-1, S...>{};
+template<int ...S> struct gens<0, S...> {typedef seq<S...> type;};
+
+/// Used for expanding a C++ std::tuple into a boost::python::tuple
+template <typename ...Args>
+struct cpptuple2pytuple_wrapper {
+    std::tuple<Args...> params;
+    cpptuple2pytuple_wrapper(const std::tuple<Args...>& _params):params(_params){}
+
+    bp::tuple delayed_dispatch() {
+        return callFunc(typename gens<sizeof...(Args)>::type());
+    }
+
+    template<int ...S>
+    bp::tuple callFunc(seq<S...>) {
+        return bp::make_tuple(std::get<S>(params) ...);
+    }
+};
+
+/// Used for expanding a boost::python::tuple into a C++ std::tuple
+template <typename ...Args>
+struct pytuple2cpptuple_wrapper {
+    bp::tuple params;
+    pytuple2cpptuple_wrapper(const bp::tuple& _params):params(_params){}
+
+    std::tuple<Args...> delayed_dispatch() {
+        return callFunc(typename gens<sizeof...(Args)>::type());
+    }
+
+    template<int ...S>
+    std::tuple<Args...> callFunc(seq<S...>) {
+        return std::make_tuple((static_cast<Args>(bp::extract<Args>(params[S])))...);
+    }
+};
+
+/// Convert C++ std::tuple to boost::python::tuple as PyObject*.
+template<typename ... Args> PyObject* cpptuple2pytuple(const std::tuple<Args...>& t) {
+    cpptuple2pytuple_wrapper<Args...> wrapper(t);
+    bp::tuple bpt = wrapper.delayed_dispatch();
+    return bp::incref(bp::object(bpt).ptr());
+}
+
+/// Convert boost::python::tuple to C++ std::tuple.
+template<typename ... Args> std::tuple<Args...> pytuple2cpptuple(PyObject* obj) {
+    bp::tuple tup(bp::borrowed(obj));
+    pytuple2cpptuple_wrapper<Args...> wrapper(tup);
+    std::tuple<Args...> bpt = wrapper.delayed_dispatch();
+    return bpt;
+}
+
+/// To-Python converter used by Boost
+template<typename ... Args>
+struct cpptuple_to_python_tuple {
+    static PyObject* convert(const std::tuple<Args...>& t) {
+        return cpptuple2pytuple<Args...>(t);
+    }
+};
+
+/// From-Python converter used by Boost
+template<typename ... Args>
+struct cpptuple_from_python_tuple {
+    cpptuple_from_python_tuple() {
+        // actually register this converter
+        bp::converter::registry::push_back(&convertible, &construct, bp::type_id<std::tuple<Args...> >());
+    }
+
+    /// Returns NULL if the bp::tuple is not convertible
+    static void* convertible(PyObject* obj_ptr) {
+        if (!PyTuple_CheckExact(obj_ptr)) {
+            return NULL;
+        }
+        return obj_ptr;
+    }
+
+    /// Construct the std::tuple in place
+    static void construct(PyObject* obj_ptr, bp::converter::rvalue_from_python_stage1_data* data) {
+        void* storage = ((bp::converter::rvalue_from_python_storage<std::tuple<Args...> >*)data)->storage.bytes;
+        // Use placement-new to make std::tuple in memory provided by Boost
+        new (storage) std::tuple<Args...>(pytuple2cpptuple<Args...>(obj_ptr));
+        data->convertible = storage;
+    }
+};
+
+/// Create and register tuple converter as necessary
+template <typename ...TS> void create_tuple_converter() {
+    bp::type_info info = bp::type_id<std::tuple<TS...> >();
+    const bp::converter::registration* reg = bp::converter::registry::query(info);
+    // only register if not already registered!
+    if (nullptr == reg || nullptr == (*reg).m_to_python) {
+        bp::to_python_converter<std::tuple<TS...>, cpptuple_to_python_tuple<TS...> >();
+        cpptuple_from_python_tuple<TS...>();
+    }
+}
+
+/// Partial specialization of `python_converter` for std::tuple
+template <typename ...TS>
+struct python_converter<std::tuple<TS...> > {
+    static void create()
+    {
+        // register tuple converter
+        create_tuple_converter<TS...>();
+        // register converter for each type in the tuple
+        register_converter<TS...>();
+    }
+};
+
+}
+
+#endif // GADGETRON_PYTHON_MATH_TUPLE_CONVERTER_H
--- gadgetron-3.1.1.orig/toolboxes/registration/optical_flow/cpu/hoLinearResampleOperator.h
+++ gadgetron-3.1.1/toolboxes/registration/optical_flow/cpu/hoLinearResampleOperator.h
@@ -20,10 +20,6 @@ namespace Gadgetron{
     virtual void mult_MH( hoNDArray<T> *in, hoNDArray<T> *out, bool accumulate = false);
     virtual void set_displacement_field( boost::shared_ptr< hoNDArray<typename realType<T>::Type> > offsets );
     virtual void reset();
-
-    virtual boost::shared_ptr< linearOperator< hoNDArray<T> > > clone() {
-      return linearOperator< hoNDArray<T> >::clone(this);
-    }
   
   private:
     inline bool is_border_pixel( typename reald<typename realType<T>::Type,D>::Type co, typename uint64d<D>::Type dims );
--- gadgetron-3.1.1.orig/toolboxes/registration/optical_flow/gpu/cuLinearResampleOperator.h
+++ gadgetron-3.1.1/toolboxes/registration/optical_flow/gpu/cuLinearResampleOperator.h
@@ -15,10 +15,7 @@ namespace Gadgetron{
     virtual void mult_M( cuNDArray<T> *in, cuNDArray<T> *out, bool accumulate = false);
     virtual void mult_MH( cuNDArray<T> *in, cuNDArray<T> *out, bool accumulate = false);
   
-    virtual boost::shared_ptr< linearOperator< cuNDArray<T> > > clone() {
-      return linearOperator< cuNDArray<T> >::clone(this);
-    }
-  
+
   protected:
     virtual unsigned int get_num_neighbors();
     virtual void write_sort_arrays( thrust::device_vector<unsigned int> &sort_keys );
--- gadgetron-3.1.1.orig/toolboxes/registration/optical_flow/opticalFlowOperator.h
+++ gadgetron-3.1.1/toolboxes/registration/optical_flow/opticalFlowOperator.h
@@ -62,10 +62,6 @@ namespace Gadgetron {
       }
     }
 
-    virtual boost::shared_ptr< linearOperator<ARRAY_TYPE > > clone()
-      {
-	return linearOperator< ARRAY_TYPE >::clone(this);
-      }
   protected:
     std::vector< boost::shared_ptr<ARRAY_TYPE> > Ix; //Gradient along different directions
   };
